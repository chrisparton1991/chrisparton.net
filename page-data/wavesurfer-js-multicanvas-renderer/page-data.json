{"componentChunkName":"component---src-templates-post-js","path":"/wavesurfer-js-multicanvas-renderer/","webpackCompilationHash":"dd511bba6275a630ede6","result":{"data":{"ghostPost":{"id":"Ghost__Post__5d5ddfb95655c53c345c7fc7","title":"Wavesurfer.js: MultiCanvas Renderer","slug":"wavesurfer-js-multicanvas-renderer","featured":false,"feature_image":"/images/2019/08/timeline.png","excerpt":"I implemented a MultiCanvas renderer for wavesurfer, which has since been accepted into the repository and released under version 1.1.0.","custom_excerpt":"I implemented a MultiCanvas renderer for wavesurfer, which has since been accepted into the repository and released under version 1.1.0.","created_at_pretty":"22 August, 2019","published_at_pretty":"29 April, 2016","updated_at_pretty":"22 August, 2019","created_at":"2019-08-22T10:20:09.000+10:00","published_at":"2016-04-29T10:11:00.000+10:00","updated_at":"2019-08-22T11:22:17.000+10:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null}],"primary_author":{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null},"primary_tag":{"name":"software","slug":"software","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"software","slug":"software","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"This is my first blog post in quite a while. I've been busy working  away on my\nLED animation sequencing software and I'm really pleased with  the results so\nfar (a future blog post will cover the software in  detail).\n\nOne feature of the software is an audio waveform that serves the dual  purpose\nof assisting with animation timings and facilitating navigation  of the\nanimation timeline:\n\nThe Sparkled sequence timeline, including a waveform and synchronised effects\nWavesurfer.js\nTo implement the timeline, I used the excellent wavesurfer.js\n[https://web.archive.org/web/20160726051630/https://github.com/katspaugh/wavesurfer.js]\n.  Out of the box, wavesurfer comes with navigation, audio playback,  waveform\ngeneration, and a bunch of other configurations and events to  hook into.\n\nBrowser woes\nThe one issue I encountered was that large waveforms wouldn't render. After some\nresearch, I found that this was a browser limitation\n[https://web.archive.org/web/20160726051630/http://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element]\n.\n\nThe solution\nTo work around this, I implemented\n[https://web.archive.org/web/20160726051630/https://github.com/katspaugh/wavesurfer.js/pull/679] \na MultiCanvas renderer for wavesurfer, which has since been accepted into the\nrepository and released under version 1.1.0.  This was my first ever\ncontribution to an open-source project, so I was  pretty stoked to have it\naccepted and receive feedback from others.\n\nThe MultiCanvas renderer works by stacking multiple adjacent canvases, the width\nof which can be controlled by the maxCanvasWidth wavesurfer property. The\nrenderer itself can by used by setting the renderer wavesurfer property to \n'MultiCanvas'.\n\nChallenges\nWavesurfer supports two modes of rendering: lines (a  traditional waveform) and\nbars (looks like a histogram, using average  frequency values for each bar).\n\nThe below image shows a wavesurfer timeline that uses bars. I've  added a red\nline to indicate a the end of one canvas and the beginning  of the next. Notice\nthat a bar sits right on this line.\n\nSometimes, a bar needs to be rendered across two canvasesThis complicates\nthings, as the two parts of the bar need to be rendered in different canvases.\n\nMy solution for this was to wrap the canvas fillRect calls, and pass them\nthrough the following algorithm:\n\nFor each canvas:\n  Calculate intersection between canvas bounds and waveform bar coordinates\n  If an intersection exists, render the intersection to the canvas\n\nThe implementation for the line waveform was similar. I simply  rendered the\namplitude data for each canvas until I reached the end of  that canvas, then\nfilled out the line and repeated with the next canvas.\n\nAfter my initial implementation, I noticed some thin gaps between the  canvases.\nI solved this by adding a small overlap (1px * device ratio).","html":"<p>This is my first blog post in quite a while. I've been busy working  away on my LED animation sequencing software and I'm really pleased with  the results so far (a future blog post will cover the software in  detail).</p><p>One feature of the software is an audio waveform that serves the dual  purpose of assisting with animation timings and facilitating navigation  of the animation timeline:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"/images/2019/08/image-32.png\" class=\"kg-image\"><figcaption>The Sparkled sequence timeline, including a waveform and synchronised effects</figcaption></figure><!--kg-card-end: image--><h2 id=\"wavesurfer-js\">Wavesurfer.js</h2><p>To implement the timeline, I used the excellent <a href=\"https://web.archive.org/web/20160726051630/https://github.com/katspaugh/wavesurfer.js\">wavesurfer.js</a>.  Out of the box, wavesurfer comes with navigation, audio playback,  waveform generation, and a bunch of other configurations and events to  hook into.</p><h2 id=\"browser-woes\">Browser woes</h2><p>The one issue I encountered was that large waveforms wouldn't render. After some research, I found that this was a <a href=\"https://web.archive.org/web/20160726051630/http://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element\">browser limitation</a>.</p><h2 id=\"the-solution\">The solution</h2><p>To work around this, I <a href=\"https://web.archive.org/web/20160726051630/https://github.com/katspaugh/wavesurfer.js/pull/679\">implemented</a> a <code>MultiCanvas</code> renderer for wavesurfer, which has since been accepted into the repository and released under version <code>1.1.0</code>.  This was my first ever contribution to an open-source project, so I was  pretty stoked to have it accepted and receive feedback from others.</p><p>The MultiCanvas renderer works by stacking multiple adjacent canvases, the width of which can be controlled by the <code>maxCanvasWidth</code> wavesurfer property. The renderer itself can by used by setting the <code>renderer</code> wavesurfer property to <code>'MultiCanvas'</code>.</p><h2 id=\"challenges\">Challenges</h2><p>Wavesurfer supports two modes of rendering: lines (a  traditional waveform) and bars (looks like a histogram, using average  frequency values for each bar).</p><p>The below image shows a wavesurfer timeline that uses bars. I've  added a red line to indicate a the end of one canvas and the beginning  of the next. Notice that a bar sits right on this line.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"/images/2019/08/timeline-split-1.png\" class=\"kg-image\"><figcaption>Sometimes, a bar needs to be rendered across two canvases</figcaption></figure><!--kg-card-end: image--><p>This complicates things, as the two parts of the bar need to be rendered in different canvases.</p><p>My solution for this was to wrap the canvas <code>fillRect</code> calls, and pass them through the following algorithm:</p><!--kg-card-begin: code--><pre><code>For each canvas:\n  Calculate intersection between canvas bounds and waveform bar coordinates\n  If an intersection exists, render the intersection to the canvas</code></pre><!--kg-card-end: code--><p>The implementation for the line waveform was similar. I simply  rendered the amplitude data for each canvas until I reached the end of  that canvas, then filled out the line and repeated with the next canvas.</p><p>After my initial implementation, I noticed some thin gaps between the  canvases. I solved this by adding a small overlap (<code>1px * device ratio</code>).</p>","url":"http://localhost:2368/wavesurfer-js-multicanvas-renderer/","uuid":"0c3e9828-1e8c-4037-b56a-1762064c8d0f","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5d5ddfb95655c53c345c7fc7"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"wavesurfer-js-multicanvas-renderer"}}}