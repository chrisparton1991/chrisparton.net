{"componentChunkName":"component---src-templates-tag-js","path":"/blog/tag/arduino/","webpackCompilationHash":"ba540a161e85cba9bb7f","result":{"data":{"ghostTag":{"slug":"arduino","name":"arduino","visibility":"public","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5d5cef175655c53c345c7ed1","title":"Got Parts?","slug":"got-parts","featured":false,"feature_image":"http://localhost:2368/content/images/2019/08/parts.jpg","excerpt":"Today was a good day. I've been ordering electronic components on eBay like\ncrazy over the past few weeks, many of them from China. Today, the first of\nthese arrived.\n\nIt's amazing how cheap these parts are. Half of me is saying \"these parts must\nbe rubbish, they'll all die on you the moment you touch them\", and the more\noptimistic side of me is saying that China simply has vast economies of scale,\nwhich drives down the price of mass produced components such as these.\n\nI don't know how to use ma","custom_excerpt":null,"created_at_pretty":"21 August, 2019","published_at_pretty":"07 October, 2015","updated_at_pretty":"21 August, 2019","created_at":"2019-08-21T17:13:27.000+10:00","published_at":"2015-10-08T09:44:00.000+11:00","updated_at":"2019-08-21T17:18:29.000+10:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null}],"primary_author":{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null},"primary_tag":{"name":"arduino","slug":"arduino","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"arduino","slug":"arduino","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"electronics","slug":"electronics","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Today was a good day. I've been ordering electronic components on eBay like\ncrazy over the past few weeks, many of them from China. Today, the first of\nthese arrived.\n\nIt's amazing how cheap these parts are. Half of me is saying \"these parts must\nbe rubbish, they'll all die on you the moment you touch them\", and the more\noptimistic side of me is saying that China simply has vast economies of scale,\nwhich drives down the price of mass produced components such as these.\n\nI don't know how to use many of the components I've bought yet, but I plan to\nshortly, and I'll be providing updates on the quality of the components as I use\nthem.\n\nThe rest of this article is devoted to the (interesting) parts that arrived,\nwhat they do, and how cheap they are compared to Australian prices. I'm going to\nuse Jaycar for Australian pricing comparisons, as that's my go to place when I\nneed something quickly.\n\n\n--------------------------------------------------------------------------------\n\nArduino Pro Minis\nArduino Pro MiniThese little guys are a smaller version of the Arduino Uno,\nwhich is what I am using (a variant of one, anyway). Like their big brother, the \nArduino Pro Mini [https://www.arduino.cc/en/Main/ArduinoBoardProMini] boards\nsport an ATmega328 microcontroller. Despite their diminutive dimensions, they\npack 14 digital pins, 6 of which can be used for PWM.\n\nCaveats\nIt's worth noting that neither of these are not official Arduino boards, they're\nboth clones. It's also worth noting that the Australian version linked above has\nthe header pins soldered on, whereas the Chinese board ships with detached\nheader pins. The Chinese versions also need to be programmed with a UART,\nwhereas the Australian one has a micro USB port built in.\n\nVerdict\nCountry Price (Incl. Shipping) Australia\n[http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Glassware/DuinoTECH-Nano/p/XC4414] \n $29.95 China [https://www.ebay.com.au/itm/311437193162] $2.05 14.6 times\ncheaper from China, but less user friendly that the Australian counterpart. \n--------------------------------------------------------------------------------\n\nUSB 2.0 UARTs (CP2102)\nUSB 2.0 UART (CP2102)As mentioned above, the Chinese Arduino Minis don't have a\nUSB port built in. A UART has to be used to transfer software to the Arduino.\n\nCountry Price (Incl. Shipping) Australia\n[http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Glassware/Arduino-Compatible-USB-to-Serial-Adaptor-Module/p/XC4464] \n $17.95 China [https://www.ebay.com.au/itm/400565980256] $2.01 8.9 times cheaper\nfrom China, but the Australian model has mini USB. \n--------------------------------------------------------------------------------\n\nAccelerometer Modules (MPU-6050)\nMPU-6050 accelerometer moduleThese accelerometers work in three dimensions, and\nare surprisingly cheap in Australia. As seems to be a common theme here, the\nAustralian module has its pins pre-soldered, the Chinese module does not.\n\nCountry Price (Incl. Shipping) Australia\n[http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Electronic-Project-Kits/Computer-%26-Programming/3-Axis-Accelerometer-Module-for-Arduino/p/XC4478] \n $7.95 China [https://www.ebay.com.au/itm/201002005334] $2.88 2.8 times cheaper\nfrom China, but with detached header pins. \n--------------------------------------------------------------------------------\n\nJoysticks\nJoystick moduleThese joysticks support your typical up/down/left/right\ndirectional input, but can also be pushed in like a button, neat!\n\nCountry Price (Incl. Shipping) Australia\n[http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Specialty-Equipment/Arduino-Compatible-X-and-Y-Axis-Joystick-Module/p/XC4422] \n $4.95 China [https://www.ebay.com.au/itm/311154090095] $1.80 2.8 times cheaper\nfrom China, no apparent differences at first glance. \n--------------------------------------------------------------------------------\n\nBluetooth Transceivers\nBluetooth transceiver\nI was amazed to discover how cheap these things were, I was expecting to fork\nout $40+ for something like this. We live in an amazing time where awesome\ntechnologies are readily available to the masses.\n\nCountry Price (Incl. Shipping) Australia\n[http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Instruments/Arduino-Compatible-Bluetooth-Wireless-Module/p/XC4510] \n $19.95 China [https://www.ebay.com.au/itm/200924726178] $5.40 3.7 times cheaper\nfrom China, no apparent differences at first glance. \n--------------------------------------------------------------------------------\n\nTime To Experiment\nAnyway, just wanted to record some of the cool stuff I'm getting. I'm really\nlooking forward to figuring out how to use all of these parts and make something\ncool with them! I still have loads of other parts on the way too, exciting times\nahead!","html":"<p>Today was a good day. I've been ordering electronic components on eBay like crazy over the past few weeks, many of them from China. Today, the first of these arrived.</p><p>It's amazing how cheap these parts are. Half of me is saying \"these parts must be rubbish, they'll all die on you the moment you touch them\", and the more optimistic side of me is saying that China simply has vast economies of scale, which drives down the price of mass produced components such as these.</p><p>I don't know how to use many of the components I've bought yet, but I plan to shortly, and I'll be providing updates on the quality of the components as I use them.</p><p>The rest of this article is devoted to the (interesting) parts that arrived, what they do, and how cheap they are compared to Australian prices. I'm going to use Jaycar for Australian pricing comparisons, as that's my go to place when I need something quickly.</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id=\"arduino-pro-minis\">Arduino Pro Minis</h3><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image-8.png\" class=\"kg-image\"><figcaption>Arduino Pro Mini</figcaption></figure><!--kg-card-end: image--><p>These little guys are a smaller version of the Arduino Uno, which is what I am using (a variant of one, anyway). Like their big brother, the <a href=\"https://www.arduino.cc/en/Main/ArduinoBoardProMini\">Arduino Pro Mini</a> boards sport an ATmega328 microcontroller. Despite their diminutive dimensions, they pack 14 digital pins, 6 of which can be used for PWM.</p><h4 id=\"caveats\">Caveats</h4><p>It's worth noting that neither of these are not official Arduino boards, they're both clones. It's also worth noting that the Australian version linked above has the header pins soldered on, whereas the Chinese board ships with detached header pins. The Chinese versions also need to be programmed with a UART, whereas the Australian one has a micro USB port built in.</p><h3 id=\"verdict\">Verdict</h3><!--kg-card-begin: html--><table>  \n  <tbody><tr>\n    <th>Country</th>\n    <th>Price (Incl. Shipping)</th>\n  </tr>\n  <tr>\n    <td>\n<a href=\"http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Glassware/DuinoTECH-Nano/p/XC4414\">Australia</a>  \n    </td>\n    <td>$29.95</td>\n  </tr>\n  <tr>\n    <td>\n<a href=\"https://www.ebay.com.au/itm/311437193162\">China</a>  \n    </td>\n    <td>$2.05</td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">\n      <b>14.6</b> times cheaper from China, but less user friendly that the Australian counterpart.\n    </td>\n  </tr>\n</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id=\"usb-2-0-uarts-cp2102-\">USB 2.0 UARTs (CP2102)</h3><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image-9.png\" class=\"kg-image\"><figcaption>USB 2.0 UART (CP2102)</figcaption></figure><!--kg-card-end: image--><p>As mentioned above, the Chinese Arduino Minis don't have a USB port built in. A UART has to be used to transfer software to the Arduino.</p><!--kg-card-begin: html--><table>  \n  <tbody><tr>\n    <th>Country</th>\n    <th>Price (Incl. Shipping)</th>\n  </tr>\n  <tr>\n    <td>\n<a href=\"http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Glassware/Arduino-Compatible-USB-to-Serial-Adaptor-Module/p/XC4464\">Australia</a>  \n    </td>\n    <td>$17.95</td>\n  </tr>\n  <tr>\n    <td>\n<a href=\"https://www.ebay.com.au/itm/400565980256\">China</a>  \n    </td>\n    <td>$2.01</td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">\n      <b>8.9</b> times cheaper from China, but the Australian model has mini USB.\n    </td>\n  </tr>\n</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id=\"accelerometer-modules-mpu-6050-\">Accelerometer Modules (MPU-6050)</h3><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image-10.png\" class=\"kg-image\"><figcaption>MPU-6050 accelerometer module</figcaption></figure><!--kg-card-end: image--><p>These accelerometers work in three dimensions, and are surprisingly cheap in Australia. As seems to be a common theme here, the Australian module has its pins pre-soldered, the Chinese module does not.</p><!--kg-card-begin: html--><table>  \n  <tbody><tr>\n    <th>Country</th>\n    <th>Price (Incl. Shipping)</th>\n  </tr>\n  <tr>\n    <td>\n<a href=\"http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Electronic-Project-Kits/Computer-%26-Programming/3-Axis-Accelerometer-Module-for-Arduino/p/XC4478\">Australia</a>  \n    </td>\n    <td>$7.95</td>\n  </tr>\n  <tr>\n    <td>\n<a href=\"https://www.ebay.com.au/itm/201002005334\">China</a>  \n    </td>\n    <td>$2.88</td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">\n      <b>2.8</b> times cheaper from China, but with detached header pins.\n    </td>\n  </tr>\n</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id=\"joysticks\">Joysticks</h3><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image-11.png\" class=\"kg-image\"><figcaption>Joystick module</figcaption></figure><!--kg-card-end: image--><p>These joysticks support your typical up/down/left/right directional input, but can also be pushed in like a button, neat!</p><!--kg-card-begin: html--><table>  \n  <tbody><tr>\n    <th>Country</th>\n    <th>Price (Incl. Shipping)</th>\n  </tr>\n  <tr>\n    <td>\n<a href=\"http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Specialty-Equipment/Arduino-Compatible-X-and-Y-Axis-Joystick-Module/p/XC4422\">Australia</a>  \n    </td>\n    <td>$4.95</td>\n  </tr>\n  <tr>\n    <td>\n<a href=\"https://www.ebay.com.au/itm/311154090095\">China</a>  \n    </td>\n    <td>$1.80</td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">\n      <b>2.8</b> times cheaper from China, no apparent differences at first glance.\n    </td>\n  </tr>\n</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id=\"bluetooth-transceivers\">Bluetooth Transceivers</h3><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image-12.png\" class=\"kg-image\"><figcaption>Bluetooth transceiver</figcaption></figure><!--kg-card-end: image--><p><br>I was amazed to discover how cheap these things were, I was expecting to fork out $40+ for something like this. We live in an amazing time where awesome technologies are readily available to the masses.</p><!--kg-card-begin: html--><table>  \n  <tbody><tr>\n    <th>Country</th>\n    <th>Price (Incl. Shipping)</th>\n  </tr>\n  <tr>\n    <td>\n<a href=\"http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Instruments/Arduino-Compatible-Bluetooth-Wireless-Module/p/XC4510\">Australia</a>  \n    </td>\n    <td>$19.95</td>\n  </tr>\n  <tr>\n    <td>\n<a href=\"https://www.ebay.com.au/itm/200924726178\">China</a>  \n    </td>\n    <td>$5.40</td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">\n      <b>3.7</b> times cheaper from China, no apparent differences at first glance.\n    </td>\n  </tr>\n</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h2 id=\"time-to-experiment\">Time To Experiment</h2><p>Anyway, just wanted to record some of the cool stuff I'm getting. I'm really looking forward to figuring out how to use all of these parts and make something cool with them! I still have loads of other parts on the way too, exciting times ahead!</p>","url":"http://localhost:2368/got-parts/","uuid":"f843a28c-3256-4f3e-9194-2d15b02c6ec6","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5d5cef175655c53c345c7ed1"}},{"node":{"id":"Ghost__Post__5d5cecc95655c53c345c7e9c","title":"Working With An 8x8 LED Matrix","slug":"working-with-an-8x8-led-matrix","featured":false,"feature_image":"http://localhost:2368/content/images/2019/08/01.jpg","excerpt":"Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a\npurchasing frenzy, acquiring loads of various electronic components online.\n\nAmongst these was a Dual Colour 8x8 LED Matrix\n[https://littlebirdelectronics.com.au/products/led-matrix-dual-color-small]. I\nchose to work with this first because it looked like something I could tackle\nwith difficulty, which I believe is conducive to Flow\n[https://en.wikipedia.org/wiki/Flow_(psychology)]. The fact that this was the\nfirst item t","custom_excerpt":null,"created_at_pretty":"21 August, 2019","published_at_pretty":"05 October, 2015","updated_at_pretty":"21 August, 2019","created_at":"2019-08-21T17:03:37.000+10:00","published_at":"2015-10-05T11:46:00.000+11:00","updated_at":"2019-08-21T17:11:32.000+10:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null}],"primary_author":{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null},"primary_tag":{"name":"arduino","slug":"arduino","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"arduino","slug":"arduino","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"electronics","slug":"electronics","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"led","slug":"led","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a\npurchasing frenzy, acquiring loads of various electronic components online.\n\nAmongst these was a Dual Colour 8x8 LED Matrix\n[https://littlebirdelectronics.com.au/products/led-matrix-dual-color-small]. I\nchose to work with this first because it looked like something I could tackle\nwith difficulty, which I believe is conducive to Flow\n[https://en.wikipedia.org/wiki/Flow_(psychology)]. The fact that this was the\nfirst item to arrive in the mail also played a part in my decision.\n\nI set out with a goal to make a scrolling message panel, albeit a small one. I'm\npleased to say that I was able to achieve this, and I learned a lot along the\nway. I hope that by recording my projects in this blog that I'll further\nsolidify my understanding of electrical theory.\n\nThe end result is this:\n\nStep 1: What Are All These Pins For?\nThe Datasheet\n[https://cdn.sparkfun.com/datasheets/Components/LED/YSM-1288CR3G2C2.pdf] for my\nLED matrix wasn't exactly clear to me the first time I read it. The pinout\nleaves a lot to be desired as far as clarity goes:\n\nLED matrix wiring diagramSo the pinout tells us a few things:\n\n 1. There are 24 pins in total (8 red anodes, 8 green anodes, 8 common cathodes)\n 2. The pins are in a crazy order.\n\nWhat the pinout doesn't tell us, is the physical location of the pins on the\nmatrix. The matrix is perfectly square, with no indicator of which pin is pin 1.\nSo, I had to deduce that through trial and error. I wired up all of the pins,\nthen tested pins until I found the anode and cathode for a corner LED:\n\nThe LED matrix connected to a breadboardSo, we now know that two consecutive\npins can be used to power a corner LED. Given the assumption that the pins are\nordered sequentially on the LED matrix, those pins can only be the following:\n\n * Pins 2 and 3\n * Pins 10 and 11\n * Pins 14 and 15\n * Pins 22 and 23\n\nBy process of elimination, it turns out that none of the options are possible.\nThe most correct option on that list is that the circuit is using pins 22 and\n23. The only incorrect part is that the pinout states that pin 23 is connected\nto the anode for a green LED. It turns out that the datasheet is incorrect, the\nblack anodes actually depict red LEDs (lesson learned: never take a datasheet\nfor gospel).\n\nArmed with this knowledge, it was possible to figure out what all of the other\npins are for. The image below is using the same orientation as the image\nprevious image:\n\nPin diagram for the LED matrixStep 2: Wiring Up\nNow that we know what on earth the pins are for, this step is pretty easy, if\nnot a bit tedious. Since I'm using the Sparkfun Redboard\n[https://www.sparkfun.com/products/12757] (equivalent to the Arduino Uno), I\nonly have 13 digital out pins. Obviously, this isn't enough to accommodate all\nof the pins on the matrix.\n\nI decided to compromise and only use the red LEDs, which means I still need 16\npins. Fortunately, the analog in pins can also be used as digital output pins,\nso the final wiring looks like this:\n\nAs a convention, I used red and orange cables to connect to the red LED anodes,\nand green and blue cables to connect to the common cathodes. I placed 330Ω\nresistors in series with each anode connection (more on that later). The\nconnections are as follows:\n\nArduino Pin Matrix Pin Pin Type 2 11 Red Anode 3 8 Red Anode 4 5 Red Anode 5 2 \nRed Anode 6 14 Red Anode 7 17 Red Anode 8 20 Red Anode 9 23 Red Anode 11 13 \nCommon Cathode 12 10 Common Cathode A0 6 Common Cathode A1 3 Common Cathode A2 \n13 Common Cathode A3 16 Common Cathode A4 19 Common Cathode A5 22 Common Cathode \nStep 3: Making It Do Stuff\nOne hard truth I was hit with pretty early on is that making a legible picture\nshow up on this thing wasn't going to be as simple as I had hoped.\n\nThere are 16 pins wired up, each with two possible states: On or Off. This\nequates to 216 possible voltage states that the pins can be in. However, there\nare 64 LEDs wired up (disregarding the green LEDs), which equates to 264 \npossible LED states. This means that it's impossible to make any pattern of LEDs\nlight up at a given time (it's a violation of the Pigeonhole Principle\n[https://en.wikipedia.org/wiki/Pigeonhole_principle]).\n\nMy plan instead, then, was to only ever display one pixel at a time. That might\nsound like a pretty silly way to make an image scroller, but this actually isn't\ntoo dissimilar to the way old-fashioned CRT monitors work.\n\nBy turning single LEDs on for fractions of a second and repeating, we can trick\nthe human eye into perceiving a still image. By feeding multiple images into\nthis process, we can make it look like an image is moving.\n\nThe other advantage of this approach is that current will only be drawn for 0 or\n1 LED at any given instance. This means that standard resistors can be used. If\nwe were lighting up multiple pixels in a given column at the same time, a more\nsophisticated method would have to be used (and with my current skillset, I\ndon't know what that would be).\n\nStep 4: The Code\nI've included comments in the code below to act as an explanation:\n\n// The number of LEDs in the matrix in one dimension.\n#define LED_MATRIX_SIZE 8\n\n// The width of each letter when displayed on the matrix, including one column for\n// spacing between letters.\n#define LETTER_WIDTH 6\n#define REPAINT_COUNT 50\n\n// Red pins, in left-to-right order.\n// Physical pin attachments to LED matrix: 11, 8, 5, 2, 14, 17, 20, 23.\nconst byte RED_PINS[LED_MATRIX_SIZE] = {2, 3, 4, 5, 6, 7, 8, 9};\n\n// Ground pins, in top-to-bottom order (skip pin 13 to avoid using the integrated LED).\n// Physical pin attachments to LED matrix: 22, 19, 16, 13, 3, 6, 9, 12.\nconst byte GROUND_PINS[LED_MATRIX_SIZE] = {A5, A4, A3, A2, A1, A0, 12, 11};\n\n/* Binary representation of each letter, where 1 indicates an \"On\" pixel and 0 indicates\n * \"Off\", e.g. the letter \"A\" is defined as 0b0111010001111111000110001. Split into 5\n * rows and columns, that binary value looks like:\n * 0 1 1 1 0\n * 1 0 0 0 1\n * 1 1 1 1 1\n * 1 0 0 0 1\n * 1 0 0 0 1\n * \n * Notice that the \"1\" pixels form a pixel representation of the letter \"A\". The same holds\n * true for the other letters defined below.\n */\nconst long LETTERS[] = {\n  0b0111010001111111000110001, // 'A'\n  0b1111010001111101000111110, // 'B'\n  0b0111010001100001000101110, // 'C'\n  0b1111010001100011000111110, // 'D'\n  0b1111110000111101000011111, // 'E'\n  0b1111110000111101000010000, // 'F'\n  0b0111010000101111001001110, // 'G'\n  0b1000110001111111000110001, // 'H'\n  0b1111100100001000010011111, // 'I'\n  0b0011100010000101001001100, // 'J'\n  0b1000110010111001001010001, // 'K'\n  0b1000010000100001000011111, // 'L'\n  0b0101010101101011000110001, // 'M'\n  0b1000111001101011001110001, // 'N'\n  0b0111010001100011000101110, // 'O'\n  0b1111010001111101000010000, // 'P'\n  0b0110010010101101001001101, // 'Q'\n  0b1111010001111101001010001, // 'R'\n  0b0111110000011100000111110, // 'S'\n  0b1111100100001000010000100, // 'T'\n  0b1000110001100011000101110, // 'U'\n  0b1000110001100010101000100, // 'V'\n  0b1000110001101011101110001, // 'W'\n  0b1000101010001000101010001, // 'X'\n  0b1000101010001000010000100, // 'Y'\n  0b1111100010001000100011111  // 'Z'\n};\n\n// Set all pins to output, so we can change the potential difference between\n// positive and negative pins. We also default the cathode pins to HIGH, which creates\n// a negative potential difference that results in no LEDs turning on.\nvoid setup() {\n  for (byte i = 0; i < LED_MATRIX_SIZE; ++i) {\n    byte anodePin = RED_PINS[i];\n    pinMode(anodePin, OUTPUT);\n    \n    byte groundPin = GROUND_PINS[i];\n    pinMode(groundPin, OUTPUT);\n\n    digitalWrite(GROUND_PINS[i], HIGH);\n  }\n}\n\nvoid loop() {\n  renderMessage();\n}\n\nvoid renderMessage() {\n  // The message to display on the screen, with some space for padding\n  // when displaying the message.\n  char message[] = \" I AM ALIVE \";\n\n  int messageIndex = 0;\n  char messageChar = message[messageIndex];\n\n  while (messageChar != '\\0') {\n    char nextChar = message[messageIndex + 1];\n    if (nextChar == '\\0') {\n      nextChar = ' ';\n    }\n\n    renderFrame(messageChar, nextChar);\n\n    ++messageIndex;\n    messageChar = message[messageIndex]; \n  }\n}\n\n// 2 characters are always present on the screen. This function handles the drawing of those two\n// characters in such a way that they scroll off the screen to the left. As soon as the first\n// character is invisible, the function exits and is called again with a new secondChar,\n// while the previous secondChar is passed in as the new firstChar.\nvoid renderFrame(char firstChar, char secondChar) {\n  for (byte i = 0; i < LETTER_WIDTH; ++i) {\n    for (byte j = 0; j < REPAINT_COUNT; ++j) {\n      boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE] = {};\n      \n      renderCharacter(frame, firstChar, -i);\n      renderCharacter(frame, secondChar, 6 - i);\n\n      renderFrame(frame);\n      delay(1);\n    }\n  }\n}\n\n// Draws a pixel representation of a single letter to the frame buffer.\nvoid renderCharacter(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE], char character, int offset) {\n  for (int row = 0; row < 5; ++row) {\n    for (int col = 0; col < 5; ++col) {\n      int bitCount = (row * 5) + col;\n\n      long displayCharacter;\n      if (character == ' ') {\n        displayCharacter = 0; // All spaces.\n      } else {\n        displayCharacter = LETTERS[character - 'A'];\n      }\n\n      // This is where the magic happens. The left shift and binary AND operations are used\n      // together to effectively iterate over each bit of the character as defined in the\n      // LETTERS array. This results in a 1 or 0, which is used to dictate whether a pixel\n      // should be turned on or off for a given point.\n      boolean isOn = displayCharacter & (1L << (24 - bitCount));\n\n      // Only render the visible parts of the letter (part of the letter is likely to have\n      // scrolled off the screen.\n      int offsetCol = col + offset;\n      if (offsetCol >= 0 && offsetCol < LED_MATRIX_SIZE) {\n        frame[row][offsetCol] = isOn;\n      }\n    }\n  }\n}\n\n// Converts the in-memory frame buffer into an actual image. This is achieved by rapidly\n// turning on single LEDs that correspond to \"true\" values in the frame buffer, then turning\n// them off after a short delay.\n// A single pixel is turned on by bringing the anode pin HIGH and the corresponding cathode pin\n// LOW. Remember that all cathodes were brought HIGH earlier in the setup() function.\nvoid renderFrame(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE]) {\n  for (byte row = 0; row < LED_MATRIX_SIZE; ++row) {\n    for (byte col = 0; col < LED_MATRIX_SIZE; ++col) {\n        // Turn pixel on or off as required.\n        digitalWrite(RED_PINS[row], frame[row][col]);\n        digitalWrite(GROUND_PINS[col], !frame[row][col]);\n\n        // Turn pixel back off.\n        digitalWrite(RED_PINS[row], LOW);\n        digitalWrite(GROUND_PINS[col], HIGH);\n    }\n  }\n}\n\n\nThat's All There Is To It\nIf you've made it to the end of this article, thanks for your patience. This is\nmy first blog post of substance, and I'd love to hear any feedback or\nconstructive criticism in the comments section below. Cheers!","html":"<p>Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a purchasing frenzy, acquiring loads of various electronic components online.</p><p>Amongst these was a <a href=\"https://littlebirdelectronics.com.au/products/led-matrix-dual-color-small\">Dual Colour 8x8 LED Matrix</a>. I chose to work with this first because it looked like something I could tackle with difficulty, which I believe is conducive to <a href=\"https://en.wikipedia.org/wiki/Flow_(psychology)\">Flow</a>. The fact that this was the first item to arrive in the mail also played a part in my decision.</p><p>I set out with a goal to make a scrolling message panel, albeit a small one. I'm pleased to say that I was able to achieve this, and I learned a lot along the way. I hope that by recording my projects in this blog that I'll further solidify my understanding of electrical theory.</p><p>The end result is this:</p><h2 id=\"step-1-what-are-all-these-pins-for\">Step 1: What Are All These Pins For?</h2><p>The <a href=\"https://cdn.sparkfun.com/datasheets/Components/LED/YSM-1288CR3G2C2.pdf\">Datasheet</a> for my LED matrix wasn't exactly clear to me the first time I read it. The pinout leaves a lot to be desired as far as clarity goes:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image.png\" class=\"kg-image\"><figcaption>LED matrix wiring diagram</figcaption></figure><!--kg-card-end: image--><p>So the pinout tells us a few things:</p><ol><li>There are 24 pins in total (8 red anodes, 8 green anodes, 8 common cathodes)</li><li>The pins are in a crazy order.</li></ol><p>What the pinout <em>doesn't</em> tell us, is the physical location of the pins on the matrix. The matrix is perfectly square, with no indicator of which pin is pin 1. So, I had to deduce that through trial and error. I wired up all of the pins, then tested pins until I found the anode and cathode for a corner LED:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image-1.png\" class=\"kg-image\"><figcaption>The LED matrix connected to a breadboard</figcaption></figure><!--kg-card-end: image--><p>So, we now know that two consecutive pins can be used to power a corner LED. Given the assumption that the pins are ordered sequentially on the LED matrix, those pins can only be the following:</p><ul><li>Pins 2 and 3</li><li>Pins 10 and 11</li><li>Pins 14 and 15</li><li>Pins 22 and 23</li></ul><p>By process of elimination, it turns out that none of the options are possible. The most correct option on that list is that the circuit is using pins 22 and 23. The only incorrect part is that the pinout states that pin 23 is connected to the anode for a <em>green</em> LED. It turns out that the datasheet is incorrect, the black anodes actually depict <em>red</em> LEDs (lesson learned: never take a datasheet for gospel).</p><p>Armed with this knowledge, it was possible to figure out what all of the other pins are for. The image below is using the same orientation as the image previous image:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-width-full kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2019/08/image-2.png\" class=\"kg-image\"><figcaption>Pin diagram for the LED matrix</figcaption></figure><!--kg-card-end: image--><h2 id=\"step-2-wiring-up\">Step 2: Wiring Up</h2><p>Now that we know what on earth the pins are for, this step is pretty easy, if not a bit tedious. Since I'm using the <a href=\"https://www.sparkfun.com/products/12757\">Sparkfun Redboard</a> (equivalent to the Arduino Uno), I only have 13 digital out pins. Obviously, this isn't enough to accommodate all of the pins on the matrix.</p><p>I decided to compromise and only use the red LEDs, which means I still need 16 pins. Fortunately, the analog in pins can also be used as digital output pins, so the final wiring looks like this:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"http://localhost:2368/content/images/2019/08/image-3.png\" class=\"kg-image\"></figure><!--kg-card-end: image--><p>As a convention, I used red and orange cables to connect to the red LED anodes, and green and blue cables to connect to the common cathodes. I placed 330Ω resistors in series with each anode connection (more on that later). The connections are as follows:</p><!--kg-card-begin: html--><table style=\"table-layout: fixed ; width: auto\">  \n  <tbody><tr>\n    <th>Arduino Pin</th>\n    <th>Matrix Pin</th>\n    <th>Pin Type</th>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>11</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>3</td>\n    <td>8</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>4</td>\n    <td>5</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>5</td>\n    <td>2</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>6</td>\n    <td>14</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>7</td>\n    <td>17</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>8</td>\n    <td>20</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>9</td>\n    <td>23</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>11</td>\n    <td>13</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>12</td>\n    <td>10</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A0</td>\n    <td>6</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A1</td>\n    <td>3</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A2</td>\n    <td>13</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A3</td>\n    <td>16</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A4</td>\n    <td>19</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A5</td>\n    <td>22</td>\n    <td>Common Cathode</td>\n  </tr>\n</tbody></table><!--kg-card-end: html--><h2 id=\"step-3-making-it-do-stuff\">Step 3: Making It Do Stuff</h2><p>One hard truth I was hit with pretty early on is that making a legible picture show up on this thing wasn't going to be as simple as I had hoped.</p><p>There are 16 pins wired up, each with two possible states: On or Off. This equates to 2<sup>16</sup> possible voltage states that the pins can be in. However, there are 64 LEDs wired up (disregarding the green LEDs), which equates to 2<sup>64</sup> possible LED states. This means that it's impossible to make any pattern of LEDs light up at a given time (it's a violation of the <a href=\"https://en.wikipedia.org/wiki/Pigeonhole_principle\">Pigeonhole Principle</a>).</p><p>My plan instead, then, was to only ever display one pixel at a time. That might sound like a pretty silly way to make an image scroller, but this actually isn't too dissimilar to the way old-fashioned CRT monitors work.</p><p>By turning single LEDs on for fractions of a second and repeating, we can trick the human eye into perceiving a still image. By feeding multiple images into this process, we can make it look like an image is moving.</p><p>The other advantage of this approach is that current will only be drawn for 0 or 1 LED at any given instance. This means that standard resistors can be used. If we were lighting up multiple pixels in a given column at the same time, a more sophisticated method would have to be used (and with my current skillset, I don't know what that would be).</p><h2 id=\"step-4-the-code\">Step 4: The Code</h2><p>I've included comments in the code below to act as an explanation:</p><!--kg-card-begin: code--><pre><code class=\"language-language-cpp\">// The number of LEDs in the matrix in one dimension.\n#define LED_MATRIX_SIZE 8\n\n// The width of each letter when displayed on the matrix, including one column for\n// spacing between letters.\n#define LETTER_WIDTH 6\n#define REPAINT_COUNT 50\n\n// Red pins, in left-to-right order.\n// Physical pin attachments to LED matrix: 11, 8, 5, 2, 14, 17, 20, 23.\nconst byte RED_PINS[LED_MATRIX_SIZE] = {2, 3, 4, 5, 6, 7, 8, 9};\n\n// Ground pins, in top-to-bottom order (skip pin 13 to avoid using the integrated LED).\n// Physical pin attachments to LED matrix: 22, 19, 16, 13, 3, 6, 9, 12.\nconst byte GROUND_PINS[LED_MATRIX_SIZE] = {A5, A4, A3, A2, A1, A0, 12, 11};\n\n/* Binary representation of each letter, where 1 indicates an \"On\" pixel and 0 indicates\n * \"Off\", e.g. the letter \"A\" is defined as 0b0111010001111111000110001. Split into 5\n * rows and columns, that binary value looks like:\n * 0 1 1 1 0\n * 1 0 0 0 1\n * 1 1 1 1 1\n * 1 0 0 0 1\n * 1 0 0 0 1\n * \n * Notice that the \"1\" pixels form a pixel representation of the letter \"A\". The same holds\n * true for the other letters defined below.\n */\nconst long LETTERS[] = {\n  0b0111010001111111000110001, // 'A'\n  0b1111010001111101000111110, // 'B'\n  0b0111010001100001000101110, // 'C'\n  0b1111010001100011000111110, // 'D'\n  0b1111110000111101000011111, // 'E'\n  0b1111110000111101000010000, // 'F'\n  0b0111010000101111001001110, // 'G'\n  0b1000110001111111000110001, // 'H'\n  0b1111100100001000010011111, // 'I'\n  0b0011100010000101001001100, // 'J'\n  0b1000110010111001001010001, // 'K'\n  0b1000010000100001000011111, // 'L'\n  0b0101010101101011000110001, // 'M'\n  0b1000111001101011001110001, // 'N'\n  0b0111010001100011000101110, // 'O'\n  0b1111010001111101000010000, // 'P'\n  0b0110010010101101001001101, // 'Q'\n  0b1111010001111101001010001, // 'R'\n  0b0111110000011100000111110, // 'S'\n  0b1111100100001000010000100, // 'T'\n  0b1000110001100011000101110, // 'U'\n  0b1000110001100010101000100, // 'V'\n  0b1000110001101011101110001, // 'W'\n  0b1000101010001000101010001, // 'X'\n  0b1000101010001000010000100, // 'Y'\n  0b1111100010001000100011111  // 'Z'\n};\n\n// Set all pins to output, so we can change the potential difference between\n// positive and negative pins. We also default the cathode pins to HIGH, which creates\n// a negative potential difference that results in no LEDs turning on.\nvoid setup() {\n  for (byte i = 0; i &lt; LED_MATRIX_SIZE; ++i) {\n    byte anodePin = RED_PINS[i];\n    pinMode(anodePin, OUTPUT);\n    \n    byte groundPin = GROUND_PINS[i];\n    pinMode(groundPin, OUTPUT);\n\n    digitalWrite(GROUND_PINS[i], HIGH);\n  }\n}\n\nvoid loop() {\n  renderMessage();\n}\n\nvoid renderMessage() {\n  // The message to display on the screen, with some space for padding\n  // when displaying the message.\n  char message[] = \" I AM ALIVE \";\n\n  int messageIndex = 0;\n  char messageChar = message[messageIndex];\n\n  while (messageChar != '\\0') {\n    char nextChar = message[messageIndex + 1];\n    if (nextChar == '\\0') {\n      nextChar = ' ';\n    }\n\n    renderFrame(messageChar, nextChar);\n\n    ++messageIndex;\n    messageChar = message[messageIndex]; \n  }\n}\n\n// 2 characters are always present on the screen. This function handles the drawing of those two\n// characters in such a way that they scroll off the screen to the left. As soon as the first\n// character is invisible, the function exits and is called again with a new secondChar,\n// while the previous secondChar is passed in as the new firstChar.\nvoid renderFrame(char firstChar, char secondChar) {\n  for (byte i = 0; i &lt; LETTER_WIDTH; ++i) {\n    for (byte j = 0; j &lt; REPAINT_COUNT; ++j) {\n      boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE] = {};\n      \n      renderCharacter(frame, firstChar, -i);\n      renderCharacter(frame, secondChar, 6 - i);\n\n      renderFrame(frame);\n      delay(1);\n    }\n  }\n}\n\n// Draws a pixel representation of a single letter to the frame buffer.\nvoid renderCharacter(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE], char character, int offset) {\n  for (int row = 0; row &lt; 5; ++row) {\n    for (int col = 0; col &lt; 5; ++col) {\n      int bitCount = (row * 5) + col;\n\n      long displayCharacter;\n      if (character == ' ') {\n        displayCharacter = 0; // All spaces.\n      } else {\n        displayCharacter = LETTERS[character - 'A'];\n      }\n\n      // This is where the magic happens. The left shift and binary AND operations are used\n      // together to effectively iterate over each bit of the character as defined in the\n      // LETTERS array. This results in a 1 or 0, which is used to dictate whether a pixel\n      // should be turned on or off for a given point.\n      boolean isOn = displayCharacter &amp; (1L &lt;&lt; (24 - bitCount));\n\n      // Only render the visible parts of the letter (part of the letter is likely to have\n      // scrolled off the screen.\n      int offsetCol = col + offset;\n      if (offsetCol &gt;= 0 &amp;&amp; offsetCol &lt; LED_MATRIX_SIZE) {\n        frame[row][offsetCol] = isOn;\n      }\n    }\n  }\n}\n\n// Converts the in-memory frame buffer into an actual image. This is achieved by rapidly\n// turning on single LEDs that correspond to \"true\" values in the frame buffer, then turning\n// them off after a short delay.\n// A single pixel is turned on by bringing the anode pin HIGH and the corresponding cathode pin\n// LOW. Remember that all cathodes were brought HIGH earlier in the setup() function.\nvoid renderFrame(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE]) {\n  for (byte row = 0; row &lt; LED_MATRIX_SIZE; ++row) {\n    for (byte col = 0; col &lt; LED_MATRIX_SIZE; ++col) {\n        // Turn pixel on or off as required.\n        digitalWrite(RED_PINS[row], frame[row][col]);\n        digitalWrite(GROUND_PINS[col], !frame[row][col]);\n\n        // Turn pixel back off.\n        digitalWrite(RED_PINS[row], LOW);\n        digitalWrite(GROUND_PINS[col], HIGH);\n    }\n  }\n}\n</code></pre><!--kg-card-end: code--><h2 id=\"that-s-all-there-is-to-it\">That's All There Is To It</h2><p>If you've made it to the end of this article, thanks for your patience. This is my first blog post of substance, and I'd love to hear any feedback or constructive criticism in the comments section below. Cheers!</p>","url":"http://localhost:2368/working-with-an-8x8-led-matrix/","uuid":"a4bf4ed8-e393-43cb-b26d-ad2429f77e10","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5d5cecc95655c53c345c7e9c"}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"arduino","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}}}