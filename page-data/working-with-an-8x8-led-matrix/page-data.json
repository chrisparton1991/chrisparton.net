{"componentChunkName":"component---src-templates-post-js","path":"/working-with-an-8x8-led-matrix/","webpackCompilationHash":"dd511bba6275a630ede6","result":{"data":{"ghostPost":{"id":"Ghost__Post__5d5cecc95655c53c345c7e9c","title":"Working With An 8x8 LED Matrix","slug":"working-with-an-8x8-led-matrix","featured":false,"feature_image":"https://chrisparton.net/content/images/2019/08/01.jpg","excerpt":"Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a purchasing frenzy, acquiring loads of various electronic components online.\n\nAmongst these was a Dual Colour 8x8 LED Matrix.","custom_excerpt":"Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a purchasing frenzy, acquiring loads of various electronic components online.\n\nAmongst these was a Dual Colour 8x8 LED Matrix.","created_at_pretty":"21 August, 2019","published_at_pretty":"05 October, 2015","updated_at_pretty":"21 August, 2019","created_at":"2019-08-21T17:03:37.000+10:00","published_at":"2015-10-05T11:46:00.000+11:00","updated_at":"2019-08-21T20:55:01.000+10:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null}],"primary_author":{"name":"Chris Parton","slug":"chris","bio":null,"profile_image":"//www.gravatar.com/avatar/6b7434bbe636033b9d4be00df745f7f1?s=250&d=mm&r=x","twitter":"@chrislights_","facebook":null,"website":null},"primary_tag":{"name":"arduino","slug":"arduino","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"arduino","slug":"arduino","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"electronics","slug":"electronics","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"led","slug":"led","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a\npurchasing frenzy, acquiring loads of various electronic components online.\n\nAmongst these was a Dual Colour 8x8 LED Matrix\n[https://littlebirdelectronics.com.au/products/led-matrix-dual-color-small]. I\nchose to work with this first because it looked like something I could tackle\nwith difficulty, which I believe is conducive to Flow\n[https://en.wikipedia.org/wiki/Flow_(psychology)]. The fact that this was the\nfirst item to arrive in the mail also played a part in my decision.\n\nI set out with a goal to make a scrolling message panel, albeit a small one. I'm\npleased to say that I was able to achieve this, and I learned a lot along the\nway. I hope that by recording my projects in this blog that I'll further\nsolidify my understanding of electrical theory.\n\nThe end result is this:\n\nStep 1: What Are All These Pins For?\nThe Datasheet\n[https://cdn.sparkfun.com/datasheets/Components/LED/YSM-1288CR3G2C2.pdf] for my\nLED matrix wasn't exactly clear to me the first time I read it. The pinout\nleaves a lot to be desired as far as clarity goes:\n\nLED matrix wiring diagramSo the pinout tells us a few things:\n\n 1. There are 24 pins in total (8 red anodes, 8 green anodes, 8 common cathodes)\n 2. The pins are in a crazy order.\n\nWhat the pinout doesn't tell us, is the physical location of the pins on the\nmatrix. The matrix is perfectly square, with no indicator of which pin is pin 1.\nSo, I had to deduce that through trial and error. I wired up all of the pins,\nthen tested pins until I found the anode and cathode for a corner LED:\n\nThe LED matrix connected to a breadboardSo, we now know that two consecutive\npins can be used to power a corner LED. Given the assumption that the pins are\nordered sequentially on the LED matrix, those pins can only be the following:\n\n * Pins 2 and 3\n * Pins 10 and 11\n * Pins 14 and 15\n * Pins 22 and 23\n\nBy process of elimination, it turns out that none of the options are possible.\nThe most correct option on that list is that the circuit is using pins 22 and\n23. The only incorrect part is that the pinout states that pin 23 is connected\nto the anode for a green LED. It turns out that the datasheet is incorrect, the\nblack anodes actually depict red LEDs (lesson learned: never take a datasheet\nfor gospel).\n\nArmed with this knowledge, it was possible to figure out what all of the other\npins are for. The image below is using the same orientation as the image\nprevious image:\n\nPin diagram for the LED matrixStep 2: Wiring Up\nNow that we know what on earth the pins are for, this step is pretty easy, if\nnot a bit tedious. Since I'm using the Sparkfun Redboard\n[https://www.sparkfun.com/products/12757] (equivalent to the Arduino Uno), I\nonly have 13 digital out pins. Obviously, this isn't enough to accommodate all\nof the pins on the matrix.\n\nI decided to compromise and only use the red LEDs, which means I still need 16\npins. Fortunately, the analog in pins can also be used as digital output pins,\nso the final wiring looks like this:\n\nAs a convention, I used red and orange cables to connect to the red LED anodes,\nand green and blue cables to connect to the common cathodes. I placed 330â„¦\nresistors in series with each anode connection (more on that later). The\nconnections are as follows:\n\nArduino Pin Matrix Pin Pin Type 2 11 Red Anode 3 8 Red Anode 4 5 Red Anode 5 2 \nRed Anode 6 14 Red Anode 7 17 Red Anode 8 20 Red Anode 9 23 Red Anode 11 13 \nCommon Cathode 12 10 Common Cathode A0 6 Common Cathode A1 3 Common Cathode A2 \n13 Common Cathode A3 16 Common Cathode A4 19 Common Cathode A5 22 Common Cathode \nStep 3: Making It Do Stuff\nOne hard truth I was hit with pretty early on is that making a legible picture\nshow up on this thing wasn't going to be as simple as I had hoped.\n\nThere are 16 pins wired up, each with two possible states: On or Off. This\nequates to 216 possible voltage states that the pins can be in. However, there\nare 64 LEDs wired up (disregarding the green LEDs), which equates to 264 \npossible LED states. This means that it's impossible to make any pattern of LEDs\nlight up at a given time (it's a violation of the Pigeonhole Principle\n[https://en.wikipedia.org/wiki/Pigeonhole_principle]).\n\nMy plan instead, then, was to only ever display one pixel at a time. That might\nsound like a pretty silly way to make an image scroller, but this actually isn't\ntoo dissimilar to the way old-fashioned CRT monitors work.\n\nBy turning single LEDs on for fractions of a second and repeating, we can trick\nthe human eye into perceiving a still image. By feeding multiple images into\nthis process, we can make it look like an image is moving.\n\nThe other advantage of this approach is that current will only be drawn for 0 or\n1 LED at any given instance. This means that standard resistors can be used. If\nwe were lighting up multiple pixels in a given column at the same time, a more\nsophisticated method would have to be used (and with my current skillset, I\ndon't know what that would be).\n\nStep 4: The Code\nI've included comments in the code below to act as an explanation:\n\n// The number of LEDs in the matrix in one dimension.\n#define LED_MATRIX_SIZE 8\n\n// The width of each letter when displayed on the matrix, including one column for\n// spacing between letters.\n#define LETTER_WIDTH 6\n#define REPAINT_COUNT 50\n\n// Red pins, in left-to-right order.\n// Physical pin attachments to LED matrix: 11, 8, 5, 2, 14, 17, 20, 23.\nconst byte RED_PINS[LED_MATRIX_SIZE] = {2, 3, 4, 5, 6, 7, 8, 9};\n\n// Ground pins, in top-to-bottom order (skip pin 13 to avoid using the integrated LED).\n// Physical pin attachments to LED matrix: 22, 19, 16, 13, 3, 6, 9, 12.\nconst byte GROUND_PINS[LED_MATRIX_SIZE] = {A5, A4, A3, A2, A1, A0, 12, 11};\n\n/* Binary representation of each letter, where 1 indicates an \"On\" pixel and 0 indicates\n * \"Off\", e.g. the letter \"A\" is defined as 0b0111010001111111000110001. Split into 5\n * rows and columns, that binary value looks like:\n * 0 1 1 1 0\n * 1 0 0 0 1\n * 1 1 1 1 1\n * 1 0 0 0 1\n * 1 0 0 0 1\n * \n * Notice that the \"1\" pixels form a pixel representation of the letter \"A\". The same holds\n * true for the other letters defined below.\n */\nconst long LETTERS[] = {\n  0b0111010001111111000110001, // 'A'\n  0b1111010001111101000111110, // 'B'\n  0b0111010001100001000101110, // 'C'\n  0b1111010001100011000111110, // 'D'\n  0b1111110000111101000011111, // 'E'\n  0b1111110000111101000010000, // 'F'\n  0b0111010000101111001001110, // 'G'\n  0b1000110001111111000110001, // 'H'\n  0b1111100100001000010011111, // 'I'\n  0b0011100010000101001001100, // 'J'\n  0b1000110010111001001010001, // 'K'\n  0b1000010000100001000011111, // 'L'\n  0b0101010101101011000110001, // 'M'\n  0b1000111001101011001110001, // 'N'\n  0b0111010001100011000101110, // 'O'\n  0b1111010001111101000010000, // 'P'\n  0b0110010010101101001001101, // 'Q'\n  0b1111010001111101001010001, // 'R'\n  0b0111110000011100000111110, // 'S'\n  0b1111100100001000010000100, // 'T'\n  0b1000110001100011000101110, // 'U'\n  0b1000110001100010101000100, // 'V'\n  0b1000110001101011101110001, // 'W'\n  0b1000101010001000101010001, // 'X'\n  0b1000101010001000010000100, // 'Y'\n  0b1111100010001000100011111  // 'Z'\n};\n\n// Set all pins to output, so we can change the potential difference between\n// positive and negative pins. We also default the cathode pins to HIGH, which creates\n// a negative potential difference that results in no LEDs turning on.\nvoid setup() {\n  for (byte i = 0; i < LED_MATRIX_SIZE; ++i) {\n    byte anodePin = RED_PINS[i];\n    pinMode(anodePin, OUTPUT);\n    \n    byte groundPin = GROUND_PINS[i];\n    pinMode(groundPin, OUTPUT);\n\n    digitalWrite(GROUND_PINS[i], HIGH);\n  }\n}\n\nvoid loop() {\n  renderMessage();\n}\n\nvoid renderMessage() {\n  // The message to display on the screen, with some space for padding\n  // when displaying the message.\n  char message[] = \" I AM ALIVE \";\n\n  int messageIndex = 0;\n  char messageChar = message[messageIndex];\n\n  while (messageChar != '\\0') {\n    char nextChar = message[messageIndex + 1];\n    if (nextChar == '\\0') {\n      nextChar = ' ';\n    }\n\n    renderFrame(messageChar, nextChar);\n\n    ++messageIndex;\n    messageChar = message[messageIndex]; \n  }\n}\n\n// 2 characters are always present on the screen. This function handles the drawing of those two\n// characters in such a way that they scroll off the screen to the left. As soon as the first\n// character is invisible, the function exits and is called again with a new secondChar,\n// while the previous secondChar is passed in as the new firstChar.\nvoid renderFrame(char firstChar, char secondChar) {\n  for (byte i = 0; i < LETTER_WIDTH; ++i) {\n    for (byte j = 0; j < REPAINT_COUNT; ++j) {\n      boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE] = {};\n      \n      renderCharacter(frame, firstChar, -i);\n      renderCharacter(frame, secondChar, 6 - i);\n\n      renderFrame(frame);\n      delay(1);\n    }\n  }\n}\n\n// Draws a pixel representation of a single letter to the frame buffer.\nvoid renderCharacter(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE], char character, int offset) {\n  for (int row = 0; row < 5; ++row) {\n    for (int col = 0; col < 5; ++col) {\n      int bitCount = (row * 5) + col;\n\n      long displayCharacter;\n      if (character == ' ') {\n        displayCharacter = 0; // All spaces.\n      } else {\n        displayCharacter = LETTERS[character - 'A'];\n      }\n\n      // This is where the magic happens. The left shift and binary AND operations are used\n      // together to effectively iterate over each bit of the character as defined in the\n      // LETTERS array. This results in a 1 or 0, which is used to dictate whether a pixel\n      // should be turned on or off for a given point.\n      boolean isOn = displayCharacter & (1L << (24 - bitCount));\n\n      // Only render the visible parts of the letter (part of the letter is likely to have\n      // scrolled off the screen.\n      int offsetCol = col + offset;\n      if (offsetCol >= 0 && offsetCol < LED_MATRIX_SIZE) {\n        frame[row][offsetCol] = isOn;\n      }\n    }\n  }\n}\n\n// Converts the in-memory frame buffer into an actual image. This is achieved by rapidly\n// turning on single LEDs that correspond to \"true\" values in the frame buffer, then turning\n// them off after a short delay.\n// A single pixel is turned on by bringing the anode pin HIGH and the corresponding cathode pin\n// LOW. Remember that all cathodes were brought HIGH earlier in the setup() function.\nvoid renderFrame(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE]) {\n  for (byte row = 0; row < LED_MATRIX_SIZE; ++row) {\n    for (byte col = 0; col < LED_MATRIX_SIZE; ++col) {\n        // Turn pixel on or off as required.\n        digitalWrite(RED_PINS[row], frame[row][col]);\n        digitalWrite(GROUND_PINS[col], !frame[row][col]);\n\n        // Turn pixel back off.\n        digitalWrite(RED_PINS[row], LOW);\n        digitalWrite(GROUND_PINS[col], HIGH);\n    }\n  }\n}\n\n\nThat's All There Is To It\nIf you've made it to the end of this article, thanks for your patience. This is\nmy first blog post of substance, and I'd love to hear any feedback or\nconstructive criticism in the comments section below. Cheers!","html":"<p>Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a purchasing frenzy, acquiring loads of various electronic components online.</p><p>Amongst these was a <a href=\"https://littlebirdelectronics.com.au/products/led-matrix-dual-color-small\">Dual Colour 8x8 LED Matrix</a>. I chose to work with this first because it looked like something I could tackle with difficulty, which I believe is conducive to <a href=\"https://en.wikipedia.org/wiki/Flow_(psychology)\">Flow</a>. The fact that this was the first item to arrive in the mail also played a part in my decision.</p><p>I set out with a goal to make a scrolling message panel, albeit a small one. I'm pleased to say that I was able to achieve this, and I learned a lot along the way. I hope that by recording my projects in this blog that I'll further solidify my understanding of electrical theory.</p><p>The end result is this:</p><h2 id=\"step-1-what-are-all-these-pins-for\">Step 1: What Are All These Pins For?</h2><p>The <a href=\"https://cdn.sparkfun.com/datasheets/Components/LED/YSM-1288CR3G2C2.pdf\">Datasheet</a> for my LED matrix wasn't exactly clear to me the first time I read it. The pinout leaves a lot to be desired as far as clarity goes:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://chrisparton.net/content/images/2019/08/image.png\" class=\"kg-image\"><figcaption>LED matrix wiring diagram</figcaption></figure><!--kg-card-end: image--><p>So the pinout tells us a few things:</p><ol><li>There are 24 pins in total (8 red anodes, 8 green anodes, 8 common cathodes)</li><li>The pins are in a crazy order.</li></ol><p>What the pinout <em>doesn't</em> tell us, is the physical location of the pins on the matrix. The matrix is perfectly square, with no indicator of which pin is pin 1. So, I had to deduce that through trial and error. I wired up all of the pins, then tested pins until I found the anode and cathode for a corner LED:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://chrisparton.net/content/images/2019/08/image-1.png\" class=\"kg-image\"><figcaption>The LED matrix connected to a breadboard</figcaption></figure><!--kg-card-end: image--><p>So, we now know that two consecutive pins can be used to power a corner LED. Given the assumption that the pins are ordered sequentially on the LED matrix, those pins can only be the following:</p><ul><li>Pins 2 and 3</li><li>Pins 10 and 11</li><li>Pins 14 and 15</li><li>Pins 22 and 23</li></ul><p>By process of elimination, it turns out that none of the options are possible. The most correct option on that list is that the circuit is using pins 22 and 23. The only incorrect part is that the pinout states that pin 23 is connected to the anode for a <em>green</em> LED. It turns out that the datasheet is incorrect, the black anodes actually depict <em>red</em> LEDs (lesson learned: never take a datasheet for gospel).</p><p>Armed with this knowledge, it was possible to figure out what all of the other pins are for. The image below is using the same orientation as the image previous image:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-width-full kg-card-hascaption\"><img src=\"https://chrisparton.net/content/images/2019/08/image-2.png\" class=\"kg-image\"><figcaption>Pin diagram for the LED matrix</figcaption></figure><!--kg-card-end: image--><h2 id=\"step-2-wiring-up\">Step 2: Wiring Up</h2><p>Now that we know what on earth the pins are for, this step is pretty easy, if not a bit tedious. Since I'm using the <a href=\"https://www.sparkfun.com/products/12757\">Sparkfun Redboard</a> (equivalent to the Arduino Uno), I only have 13 digital out pins. Obviously, this isn't enough to accommodate all of the pins on the matrix.</p><p>I decided to compromise and only use the red LEDs, which means I still need 16 pins. Fortunately, the analog in pins can also be used as digital output pins, so the final wiring looks like this:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://chrisparton.net/content/images/2019/08/image-3.png\" class=\"kg-image\"></figure><!--kg-card-end: image--><p>As a convention, I used red and orange cables to connect to the red LED anodes, and green and blue cables to connect to the common cathodes. I placed 330â„¦ resistors in series with each anode connection (more on that later). The connections are as follows:</p><!--kg-card-begin: html--><table style=\"table-layout: fixed ; width: auto\">  \n  <tbody><tr>\n    <th>Arduino Pin</th>\n    <th>Matrix Pin</th>\n    <th>Pin Type</th>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>11</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>3</td>\n    <td>8</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>4</td>\n    <td>5</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>5</td>\n    <td>2</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>6</td>\n    <td>14</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>7</td>\n    <td>17</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>8</td>\n    <td>20</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>9</td>\n    <td>23</td>\n    <td>Red Anode</td>\n  </tr>\n  <tr>\n    <td>11</td>\n    <td>13</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>12</td>\n    <td>10</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A0</td>\n    <td>6</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A1</td>\n    <td>3</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A2</td>\n    <td>13</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A3</td>\n    <td>16</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A4</td>\n    <td>19</td>\n    <td>Common Cathode</td>\n  </tr>\n  <tr>\n    <td>A5</td>\n    <td>22</td>\n    <td>Common Cathode</td>\n  </tr>\n</tbody></table><!--kg-card-end: html--><h2 id=\"step-3-making-it-do-stuff\">Step 3: Making It Do Stuff</h2><p>One hard truth I was hit with pretty early on is that making a legible picture show up on this thing wasn't going to be as simple as I had hoped.</p><p>There are 16 pins wired up, each with two possible states: On or Off. This equates to 2<sup>16</sup> possible voltage states that the pins can be in. However, there are 64 LEDs wired up (disregarding the green LEDs), which equates to 2<sup>64</sup> possible LED states. This means that it's impossible to make any pattern of LEDs light up at a given time (it's a violation of the <a href=\"https://en.wikipedia.org/wiki/Pigeonhole_principle\">Pigeonhole Principle</a>).</p><p>My plan instead, then, was to only ever display one pixel at a time. That might sound like a pretty silly way to make an image scroller, but this actually isn't too dissimilar to the way old-fashioned CRT monitors work.</p><p>By turning single LEDs on for fractions of a second and repeating, we can trick the human eye into perceiving a still image. By feeding multiple images into this process, we can make it look like an image is moving.</p><p>The other advantage of this approach is that current will only be drawn for 0 or 1 LED at any given instance. This means that standard resistors can be used. If we were lighting up multiple pixels in a given column at the same time, a more sophisticated method would have to be used (and with my current skillset, I don't know what that would be).</p><h2 id=\"step-4-the-code\">Step 4: The Code</h2><p>I've included comments in the code below to act as an explanation:</p><!--kg-card-begin: code--><pre><code class=\"language-language-cpp\">// The number of LEDs in the matrix in one dimension.\n#define LED_MATRIX_SIZE 8\n\n// The width of each letter when displayed on the matrix, including one column for\n// spacing between letters.\n#define LETTER_WIDTH 6\n#define REPAINT_COUNT 50\n\n// Red pins, in left-to-right order.\n// Physical pin attachments to LED matrix: 11, 8, 5, 2, 14, 17, 20, 23.\nconst byte RED_PINS[LED_MATRIX_SIZE] = {2, 3, 4, 5, 6, 7, 8, 9};\n\n// Ground pins, in top-to-bottom order (skip pin 13 to avoid using the integrated LED).\n// Physical pin attachments to LED matrix: 22, 19, 16, 13, 3, 6, 9, 12.\nconst byte GROUND_PINS[LED_MATRIX_SIZE] = {A5, A4, A3, A2, A1, A0, 12, 11};\n\n/* Binary representation of each letter, where 1 indicates an \"On\" pixel and 0 indicates\n * \"Off\", e.g. the letter \"A\" is defined as 0b0111010001111111000110001. Split into 5\n * rows and columns, that binary value looks like:\n * 0 1 1 1 0\n * 1 0 0 0 1\n * 1 1 1 1 1\n * 1 0 0 0 1\n * 1 0 0 0 1\n * \n * Notice that the \"1\" pixels form a pixel representation of the letter \"A\". The same holds\n * true for the other letters defined below.\n */\nconst long LETTERS[] = {\n  0b0111010001111111000110001, // 'A'\n  0b1111010001111101000111110, // 'B'\n  0b0111010001100001000101110, // 'C'\n  0b1111010001100011000111110, // 'D'\n  0b1111110000111101000011111, // 'E'\n  0b1111110000111101000010000, // 'F'\n  0b0111010000101111001001110, // 'G'\n  0b1000110001111111000110001, // 'H'\n  0b1111100100001000010011111, // 'I'\n  0b0011100010000101001001100, // 'J'\n  0b1000110010111001001010001, // 'K'\n  0b1000010000100001000011111, // 'L'\n  0b0101010101101011000110001, // 'M'\n  0b1000111001101011001110001, // 'N'\n  0b0111010001100011000101110, // 'O'\n  0b1111010001111101000010000, // 'P'\n  0b0110010010101101001001101, // 'Q'\n  0b1111010001111101001010001, // 'R'\n  0b0111110000011100000111110, // 'S'\n  0b1111100100001000010000100, // 'T'\n  0b1000110001100011000101110, // 'U'\n  0b1000110001100010101000100, // 'V'\n  0b1000110001101011101110001, // 'W'\n  0b1000101010001000101010001, // 'X'\n  0b1000101010001000010000100, // 'Y'\n  0b1111100010001000100011111  // 'Z'\n};\n\n// Set all pins to output, so we can change the potential difference between\n// positive and negative pins. We also default the cathode pins to HIGH, which creates\n// a negative potential difference that results in no LEDs turning on.\nvoid setup() {\n  for (byte i = 0; i &lt; LED_MATRIX_SIZE; ++i) {\n    byte anodePin = RED_PINS[i];\n    pinMode(anodePin, OUTPUT);\n    \n    byte groundPin = GROUND_PINS[i];\n    pinMode(groundPin, OUTPUT);\n\n    digitalWrite(GROUND_PINS[i], HIGH);\n  }\n}\n\nvoid loop() {\n  renderMessage();\n}\n\nvoid renderMessage() {\n  // The message to display on the screen, with some space for padding\n  // when displaying the message.\n  char message[] = \" I AM ALIVE \";\n\n  int messageIndex = 0;\n  char messageChar = message[messageIndex];\n\n  while (messageChar != '\\0') {\n    char nextChar = message[messageIndex + 1];\n    if (nextChar == '\\0') {\n      nextChar = ' ';\n    }\n\n    renderFrame(messageChar, nextChar);\n\n    ++messageIndex;\n    messageChar = message[messageIndex]; \n  }\n}\n\n// 2 characters are always present on the screen. This function handles the drawing of those two\n// characters in such a way that they scroll off the screen to the left. As soon as the first\n// character is invisible, the function exits and is called again with a new secondChar,\n// while the previous secondChar is passed in as the new firstChar.\nvoid renderFrame(char firstChar, char secondChar) {\n  for (byte i = 0; i &lt; LETTER_WIDTH; ++i) {\n    for (byte j = 0; j &lt; REPAINT_COUNT; ++j) {\n      boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE] = {};\n      \n      renderCharacter(frame, firstChar, -i);\n      renderCharacter(frame, secondChar, 6 - i);\n\n      renderFrame(frame);\n      delay(1);\n    }\n  }\n}\n\n// Draws a pixel representation of a single letter to the frame buffer.\nvoid renderCharacter(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE], char character, int offset) {\n  for (int row = 0; row &lt; 5; ++row) {\n    for (int col = 0; col &lt; 5; ++col) {\n      int bitCount = (row * 5) + col;\n\n      long displayCharacter;\n      if (character == ' ') {\n        displayCharacter = 0; // All spaces.\n      } else {\n        displayCharacter = LETTERS[character - 'A'];\n      }\n\n      // This is where the magic happens. The left shift and binary AND operations are used\n      // together to effectively iterate over each bit of the character as defined in the\n      // LETTERS array. This results in a 1 or 0, which is used to dictate whether a pixel\n      // should be turned on or off for a given point.\n      boolean isOn = displayCharacter &amp; (1L &lt;&lt; (24 - bitCount));\n\n      // Only render the visible parts of the letter (part of the letter is likely to have\n      // scrolled off the screen.\n      int offsetCol = col + offset;\n      if (offsetCol &gt;= 0 &amp;&amp; offsetCol &lt; LED_MATRIX_SIZE) {\n        frame[row][offsetCol] = isOn;\n      }\n    }\n  }\n}\n\n// Converts the in-memory frame buffer into an actual image. This is achieved by rapidly\n// turning on single LEDs that correspond to \"true\" values in the frame buffer, then turning\n// them off after a short delay.\n// A single pixel is turned on by bringing the anode pin HIGH and the corresponding cathode pin\n// LOW. Remember that all cathodes were brought HIGH earlier in the setup() function.\nvoid renderFrame(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE]) {\n  for (byte row = 0; row &lt; LED_MATRIX_SIZE; ++row) {\n    for (byte col = 0; col &lt; LED_MATRIX_SIZE; ++col) {\n        // Turn pixel on or off as required.\n        digitalWrite(RED_PINS[row], frame[row][col]);\n        digitalWrite(GROUND_PINS[col], !frame[row][col]);\n\n        // Turn pixel back off.\n        digitalWrite(RED_PINS[row], LOW);\n        digitalWrite(GROUND_PINS[col], HIGH);\n    }\n  }\n}\n</code></pre><!--kg-card-end: code--><h2 id=\"that-s-all-there-is-to-it\">That's All There Is To It</h2><p>If you've made it to the end of this article, thanks for your patience. This is my first blog post of substance, and I'd love to hear any feedback or constructive criticism in the comments section below. Cheers!</p>","url":"https://chrisparton.net/working-with-an-8x8-led-matrix/","uuid":"a4bf4ed8-e393-43cb-b26d-ad2429f77e10","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5d5cecc95655c53c345c7e9c"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"working-with-an-8x8-led-matrix"}}}