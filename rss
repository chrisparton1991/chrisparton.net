<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[ChrisParton.net]]></title><description><![CDATA[The elation and frustration of building software and electronics.]]></description><link>https://gatsby.ghost.org/</link><image><url>https://gatsby.ghost.org/favicon.png</url><title>ChrisParton.net</title><link>https://gatsby.ghost.org/</link></image><generator>Ghost 2.9</generator><lastBuildDate>Wed, 21 Aug 2019 07:40:16 GMT</lastBuildDate><atom:link href="https://gatsby.ghost.org/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Christmas Lights 2015: A First Attempt]]></title><description><![CDATA[I've always liked Christmas lights, but my house rarely saw itself decorated
beyond the bare minimum of the Christmas tree during the festive season. Maybe a
few silver baubles and a star on the tree, but never more than that.

In December 2014, my girlfriend and I went Christmas light hunting and wound up
at Edgewood Estate [http://jamiespages.net/photo-galleries/715-2/], where
everybody seems to get into the spirit of Christmas. At the top of the estate,
almost every single home was adorned wi]]></description><link>http://localhost:2368/christmas-lights-2015-a-first-attempt/</link><guid isPermaLink="false">Ghost__Post__5d5cf1135655c53c345c7f15</guid><category><![CDATA[christmas lights]]></category><category><![CDATA[electronics]]></category><category><![CDATA[raspberry pi]]></category><category><![CDATA[software]]></category><dc:creator><![CDATA[Chris Parton]]></dc:creator><pubDate>Sat, 16 Jan 2016 22:28:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/08/xmas-lights-2015-cover.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/08/xmas-lights-2015-cover.jpg" alt="Christmas Lights 2015: A First Attempt"/><p>I've always liked Christmas lights, but my house rarely saw itself decorated beyond the bare minimum of the Christmas tree during the festive season. Maybe a few silver baubles and a star on the tree, but never more than that.</p><p>In December 2014, my girlfriend and I went Christmas light hunting and wound up at <a href="http://jamiespages.net/photo-galleries/715-2/">Edgewood Estate</a>, where everybody seems to get into the spirit of Christmas. At the top of the estate, almost every single home was adorned with beautiful lights.</p><p>What struck me about this place was the atmosphere. So many families were out enjoying the lights with their children, and everybody was some combination of happy, excited and awestruck.</p><p>This is what made me want to create my own Christmas light display; I wanted to create something that would give people that same feeling. I also wanted to create something different, using my skills as a software engineer and, more recently, as an electronics hobbyist.</p><h2 id="the-lights">The Lights</h2><p>Here is my first Christmas light attempt (Apologies for the poor audio... and video... and random talking towards the end):</p><!--kg-card-begin: embed--><figure class="kg-card kg-embed-card"><iframe width="480" height="270" src="https://www.youtube.com/embed/YddNPKLF7d0?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""/></figure><!--kg-card-end: embed--><p>I was planning on blogging about the process I went through to build my lights, but the reality is that I did it all in less than a month, learning as I went. The result of such rushed work was a functional but hacky piece of work. As such, I'll stick to describing the project at a higher level.</p><h2 id="features">Features</h2><p>The Raspberry Pi controls the lights wrapped around each pillar of the house. The other lights are not interactive in any way and have nothing to do with the Pi.</p><p>There are three main features to the pillars:</p><ol><li>Instrument playing</li><li>Song playing</li><li>"Screensaver" effects</li></ol><p>The first two features are interactive, which isn't something I've seen a lot of, even in online videos. There are plenty of insane Christmas light displays (<a href="https://www.youtube.com/watch?v=8zyoMQ4Khts">Exhibit A</a>, <a href="https://www.youtube.com/watch?v=90oZ52M4IC0">Exhibit B</a>, <a href="https://www.youtube.com/watch?v=mejJRgHpdyE">Exhibit C</a>), but for the most part they lack the ability to be influenced by spectators.</p><h4 id="instrument-and-song-playing">Instrument and Song Playing</h4><p>The interactive elements of my Christmas lights are controlled by a little button box I made by etching my own PCB and mounting it in a box:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-13.png" class="kg-image" alt="Christmas Lights 2015: A First Attempt"><figcaption>Button box</figcaption></img></figure><!--kg-card-end: image--><p>The coloured buttons are used to control the four house pillars. When a button is pressed, the corresponding pillar lights up and a musical sound is played. The pitch of the instrument increases from left to right. The white button changes the instrument between piano and violin.</p><p>The black button plays the chorus of one of four Christmas songs, and illuminates the pillars in sync with the music. This required using Audacity to find the timings of the notes, and mapping the notes to sheet music found online.</p><p>The screensaver effect is simply a series of alternating patters that are illuminated on the pillars when a button hasn't been pressed for a while.</p><h2 id="how-it-works">How It Works</h2><p>The Christmas lights on the four pillars are regular solar-powered LED strings. I cut the wires between the solar panel and the lights, and essentially ran each set of lights through a transistor. The transistors were then controlled using the GPIO pins on a Raspberry Pi using <a href="http://pi4j.com/">Pi4J</a>:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-14.png" class="kg-image" alt="Christmas Lights 2015: A First Attempt"><figcaption>Buttons and lights wired up to a Raspberry Pi</figcaption></img></figure><!--kg-card-end: image--><h2 id="what-s-next">What's Next?</h2><p>I've already started working on my Christmas lights for 2016, and I plan to keep the blog updated as I progress. So, stay tuned!</p>]]></content:encoded></item><item><title><![CDATA[I'm Back]]></title><description><![CDATA[Well, it's been a long time since I've written a blog post. I've been  both very
busy and very lazy. Since my last blog post, I've been  learning Vaadin and
Angular 1 at work, continuing my electronics  tinkering at home, and I've more
recently decided to learn how to play  the guitar.

All of these side projects (and more), coupled with the regular  demands of
life, has left me with little willpower to update this blog.  However, I have
decided to make my blog more of a priority this year.

Wit]]></description><link>http://localhost:2368/im-back/</link><guid isPermaLink="false">Ghost__Post__5d5cf0b35655c53c345c7f09</guid><category><![CDATA[miscellaneous]]></category><dc:creator><![CDATA[Chris Parton]]></dc:creator><pubDate>Sat, 16 Jan 2016 18:36:00 GMT</pubDate><content:encoded><![CDATA[<p>Well, it's been a long time since I've written a blog post. I've been  both very busy and very lazy. Since my last blog post, I've been  learning Vaadin and Angular 1 at work, continuing my electronics  tinkering at home, and I've more recently decided to learn how to play  the guitar.</p><p>All of these side projects (and more), coupled with the regular  demands of life, has left me with little willpower to update this blog.  However, I have decided to make my blog more of a priority this year.</p><p>With that in mind, it's time for me to finally document my most noteworthy project of 2015.</p>]]></content:encoded></item><item><title><![CDATA[Got Parts?]]></title><description><![CDATA[Today was a good day. I've been ordering electronic components on eBay like
crazy over the past few weeks, many of them from China. Today, the first of
these arrived.

It's amazing how cheap these parts are. Half of me is saying "these parts must
be rubbish, they'll all die on you the moment you touch them", and the more
optimistic side of me is saying that China simply has vast economies of scale,
which drives down the price of mass produced components such as these.

I don't know how to use ma]]></description><link>http://localhost:2368/got-parts/</link><guid isPermaLink="false">Ghost__Post__5d5cef175655c53c345c7ed1</guid><category><![CDATA[arduino]]></category><category><![CDATA[electronics]]></category><dc:creator><![CDATA[Chris Parton]]></dc:creator><pubDate>Wed, 07 Oct 2015 22:44:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/08/parts.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/08/parts.jpg" alt="Got Parts?"/><p>Today was a good day. I've been ordering electronic components on eBay like crazy over the past few weeks, many of them from China. Today, the first of these arrived.</p><p>It's amazing how cheap these parts are. Half of me is saying "these parts must be rubbish, they'll all die on you the moment you touch them", and the more optimistic side of me is saying that China simply has vast economies of scale, which drives down the price of mass produced components such as these.</p><p>I don't know how to use many of the components I've bought yet, but I plan to shortly, and I'll be providing updates on the quality of the components as I use them.</p><p>The rest of this article is devoted to the (interesting) parts that arrived, what they do, and how cheap they are compared to Australian prices. I'm going to use Jaycar for Australian pricing comparisons, as that's my go to place when I need something quickly.</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id="arduino-pro-minis">Arduino Pro Minis</h3><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-8.png" class="kg-image" alt="Got Parts?"><figcaption>Arduino Pro Mini</figcaption></img></figure><!--kg-card-end: image--><p>These little guys are a smaller version of the Arduino Uno, which is what I am using (a variant of one, anyway). Like their big brother, the <a href="https://www.arduino.cc/en/Main/ArduinoBoardProMini">Arduino Pro Mini</a> boards sport an ATmega328 microcontroller. Despite their diminutive dimensions, they pack 14 digital pins, 6 of which can be used for PWM.</p><h4 id="caveats">Caveats</h4><p>It's worth noting that neither of these are not official Arduino boards, they're both clones. It's also worth noting that the Australian version linked above has the header pins soldered on, whereas the Chinese board ships with detached header pins. The Chinese versions also need to be programmed with a UART, whereas the Australian one has a micro USB port built in.</p><h3 id="verdict">Verdict</h3><!--kg-card-begin: html--><table>  
  <tbody><tr>
    <th>Country</th>
    <th>Price (Incl. Shipping)</th>
  </tr>
  <tr>
    <td>
<a href="http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Glassware/DuinoTECH-Nano/p/XC4414">Australia</a>  
    </td>
    <td>$29.95</td>
  </tr>
  <tr>
    <td>
<a href="https://www.ebay.com.au/itm/311437193162">China</a>  
    </td>
    <td>$2.05</td>
  </tr>
  <tr>
    <td colspan="2">
      <b>14.6</b> times cheaper from China, but less user friendly that the Australian counterpart.
    </td>
  </tr>
</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id="usb-2-0-uarts-cp2102-">USB 2.0 UARTs (CP2102)</h3><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-9.png" class="kg-image" alt="Got Parts?"><figcaption>USB 2.0 UART (CP2102)</figcaption></img></figure><!--kg-card-end: image--><p>As mentioned above, the Chinese Arduino Minis don't have a USB port built in. A UART has to be used to transfer software to the Arduino.</p><!--kg-card-begin: html--><table>  
  <tbody><tr>
    <th>Country</th>
    <th>Price (Incl. Shipping)</th>
  </tr>
  <tr>
    <td>
<a href="http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Glassware/Arduino-Compatible-USB-to-Serial-Adaptor-Module/p/XC4464">Australia</a>  
    </td>
    <td>$17.95</td>
  </tr>
  <tr>
    <td>
<a href="https://www.ebay.com.au/itm/400565980256">China</a>  
    </td>
    <td>$2.01</td>
  </tr>
  <tr>
    <td colspan="2">
      <b>8.9</b> times cheaper from China, but the Australian model has mini USB.
    </td>
  </tr>
</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id="accelerometer-modules-mpu-6050-">Accelerometer Modules (MPU-6050)</h3><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-10.png" class="kg-image" alt="Got Parts?"><figcaption>MPU-6050 accelerometer module</figcaption></img></figure><!--kg-card-end: image--><p>These accelerometers work in three dimensions, and are surprisingly cheap in Australia. As seems to be a common theme here, the Australian module has its pins pre-soldered, the Chinese module does not.</p><!--kg-card-begin: html--><table>  
  <tbody><tr>
    <th>Country</th>
    <th>Price (Incl. Shipping)</th>
  </tr>
  <tr>
    <td>
<a href="http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Electronic-Project-Kits/Computer-%26-Programming/3-Axis-Accelerometer-Module-for-Arduino/p/XC4478">Australia</a>  
    </td>
    <td>$7.95</td>
  </tr>
  <tr>
    <td>
<a href="https://www.ebay.com.au/itm/201002005334">China</a>  
    </td>
    <td>$2.88</td>
  </tr>
  <tr>
    <td colspan="2">
      <b>2.8</b> times cheaper from China, but with detached header pins.
    </td>
  </tr>
</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id="joysticks">Joysticks</h3><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-11.png" class="kg-image" alt="Got Parts?"><figcaption>Joystick module</figcaption></img></figure><!--kg-card-end: image--><p>These joysticks support your typical up/down/left/right directional input, but can also be pushed in like a button, neat!</p><!--kg-card-begin: html--><table>  
  <tbody><tr>
    <th>Country</th>
    <th>Price (Incl. Shipping)</th>
  </tr>
  <tr>
    <td>
<a href="http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Specialty-Equipment/Arduino-Compatible-X-and-Y-Axis-Joystick-Module/p/XC4422">Australia</a>  
    </td>
    <td>$4.95</td>
  </tr>
  <tr>
    <td>
<a href="https://www.ebay.com.au/itm/311154090095">China</a>  
    </td>
    <td>$1.80</td>
  </tr>
  <tr>
    <td colspan="2">
      <b>2.8</b> times cheaper from China, no apparent differences at first glance.
    </td>
  </tr>
</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h3 id="bluetooth-transceivers">Bluetooth Transceivers</h3><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-12.png" class="kg-image" alt="Got Parts?"><figcaption>Bluetooth transceiver</figcaption></img></figure><!--kg-card-end: image--><p><br>I was amazed to discover how cheap these things were, I was expecting to fork out $40+ for something like this. We live in an amazing time where awesome technologies are readily available to the masses.</br></p><!--kg-card-begin: html--><table>  
  <tbody><tr>
    <th>Country</th>
    <th>Price (Incl. Shipping)</th>
  </tr>
  <tr>
    <td>
<a href="http://www.jaycar.com.au/Kits%2C-Science-%26-Learning/Science-Lab-Equipment/Instruments/Arduino-Compatible-Bluetooth-Wireless-Module/p/XC4510">Australia</a>  
    </td>
    <td>$19.95</td>
  </tr>
  <tr>
    <td>
<a href="https://www.ebay.com.au/itm/200924726178">China</a>  
    </td>
    <td>$5.40</td>
  </tr>
  <tr>
    <td colspan="2">
      <b>3.7</b> times cheaper from China, no apparent differences at first glance.
    </td>
  </tr>
</tbody></table><!--kg-card-end: html--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><h2 id="time-to-experiment">Time To Experiment</h2><p>Anyway, just wanted to record some of the cool stuff I'm getting. I'm really looking forward to figuring out how to use all of these parts and make something cool with them! I still have loads of other parts on the way too, exciting times ahead!</p></hr></hr></hr></hr></hr></hr>]]></content:encoded></item><item><title><![CDATA[Working With An 8x8 LED Matrix]]></title><description><![CDATA[Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a
purchasing frenzy, acquiring loads of various electronic components online.

Amongst these was a Dual Colour 8x8 LED Matrix
[https://littlebirdelectronics.com.au/products/led-matrix-dual-color-small]. I
chose to work with this first because it looked like something I could tackle
with difficulty, which I believe is conducive to Flow
[https://en.wikipedia.org/wiki/Flow_(psychology)]. The fact that this was the
first item t]]></description><link>http://localhost:2368/working-with-an-8x8-led-matrix/</link><guid isPermaLink="false">Ghost__Post__5d5cecc95655c53c345c7e9c</guid><category><![CDATA[arduino]]></category><category><![CDATA[electronics]]></category><category><![CDATA[led]]></category><dc:creator><![CDATA[Chris Parton]]></dc:creator><pubDate>Mon, 05 Oct 2015 00:46:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2019/08/01.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2019/08/01.jpg" alt="Working With An 8x8 LED Matrix"/><p>Having nearly completed the Sparkfun Inventor's Kit guidebook, I went on a purchasing frenzy, acquiring loads of various electronic components online.</p><p>Amongst these was a <a href="https://littlebirdelectronics.com.au/products/led-matrix-dual-color-small">Dual Colour 8x8 LED Matrix</a>. I chose to work with this first because it looked like something I could tackle with difficulty, which I believe is conducive to <a href="https://en.wikipedia.org/wiki/Flow_(psychology)">Flow</a>. The fact that this was the first item to arrive in the mail also played a part in my decision.</p><p>I set out with a goal to make a scrolling message panel, albeit a small one. I'm pleased to say that I was able to achieve this, and I learned a lot along the way. I hope that by recording my projects in this blog that I'll further solidify my understanding of electrical theory.</p><p>The end result is this:</p><h2 id="step-1-what-are-all-these-pins-for">Step 1: What Are All These Pins For?</h2><p>The <a href="https://cdn.sparkfun.com/datasheets/Components/LED/YSM-1288CR3G2C2.pdf">Datasheet</a> for my LED matrix wasn't exactly clear to me the first time I read it. The pinout leaves a lot to be desired as far as clarity goes:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image.png" class="kg-image" alt="Working With An 8x8 LED Matrix"><figcaption>LED matrix wiring diagram</figcaption></img></figure><!--kg-card-end: image--><p>So the pinout tells us a few things:</p><ol><li>There are 24 pins in total (8 red anodes, 8 green anodes, 8 common cathodes)</li><li>The pins are in a crazy order.</li></ol><p>What the pinout <em>doesn't</em> tell us, is the physical location of the pins on the matrix. The matrix is perfectly square, with no indicator of which pin is pin 1. So, I had to deduce that through trial and error. I wired up all of the pins, then tested pins until I found the anode and cathode for a corner LED:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-1.png" class="kg-image" alt="Working With An 8x8 LED Matrix"><figcaption>The LED matrix connected to a breadboard</figcaption></img></figure><!--kg-card-end: image--><p>So, we now know that two consecutive pins can be used to power a corner LED. Given the assumption that the pins are ordered sequentially on the LED matrix, those pins can only be the following:</p><ul><li>Pins 2 and 3</li><li>Pins 10 and 11</li><li>Pins 14 and 15</li><li>Pins 22 and 23</li></ul><p>By process of elimination, it turns out that none of the options are possible. The most correct option on that list is that the circuit is using pins 22 and 23. The only incorrect part is that the pinout states that pin 23 is connected to the anode for a <em>green</em> LED. It turns out that the datasheet is incorrect, the black anodes actually depict <em>red</em> LEDs (lesson learned: never take a datasheet for gospel).</p><p>Armed with this knowledge, it was possible to figure out what all of the other pins are for. The image below is using the same orientation as the image previous image:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-width-full kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/08/image-2.png" class="kg-image" alt="Working With An 8x8 LED Matrix"><figcaption>Pin diagram for the LED matrix</figcaption></img></figure><!--kg-card-end: image--><h2 id="step-2-wiring-up">Step 2: Wiring Up</h2><p>Now that we know what on earth the pins are for, this step is pretty easy, if not a bit tedious. Since I'm using the <a href="https://www.sparkfun.com/products/12757">Sparkfun Redboard</a> (equivalent to the Arduino Uno), I only have 13 digital out pins. Obviously, this isn't enough to accommodate all of the pins on the matrix.</p><p>I decided to compromise and only use the red LEDs, which means I still need 16 pins. Fortunately, the analog in pins can also be used as digital output pins, so the final wiring looks like this:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/08/image-3.png" class="kg-image" alt="Working With An 8x8 LED Matrix"/></figure><!--kg-card-end: image--><p>As a convention, I used red and orange cables to connect to the red LED anodes, and green and blue cables to connect to the common cathodes. I placed 330Ω resistors in series with each anode connection (more on that later). The connections are as follows:</p><!--kg-card-begin: html--><table style="table-layout: fixed ; width: auto">  
  <tbody><tr>
    <th>Arduino Pin</th>
    <th>Matrix Pin</th>
    <th>Pin Type</th>
  </tr>
  <tr>
    <td>2</td>
    <td>11</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>3</td>
    <td>8</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>4</td>
    <td>5</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>5</td>
    <td>2</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>6</td>
    <td>14</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>7</td>
    <td>17</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>8</td>
    <td>20</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>9</td>
    <td>23</td>
    <td>Red Anode</td>
  </tr>
  <tr>
    <td>11</td>
    <td>13</td>
    <td>Common Cathode</td>
  </tr>
  <tr>
    <td>12</td>
    <td>10</td>
    <td>Common Cathode</td>
  </tr>
  <tr>
    <td>A0</td>
    <td>6</td>
    <td>Common Cathode</td>
  </tr>
  <tr>
    <td>A1</td>
    <td>3</td>
    <td>Common Cathode</td>
  </tr>
  <tr>
    <td>A2</td>
    <td>13</td>
    <td>Common Cathode</td>
  </tr>
  <tr>
    <td>A3</td>
    <td>16</td>
    <td>Common Cathode</td>
  </tr>
  <tr>
    <td>A4</td>
    <td>19</td>
    <td>Common Cathode</td>
  </tr>
  <tr>
    <td>A5</td>
    <td>22</td>
    <td>Common Cathode</td>
  </tr>
</tbody></table><!--kg-card-end: html--><h2 id="step-3-making-it-do-stuff">Step 3: Making It Do Stuff</h2><p>One hard truth I was hit with pretty early on is that making a legible picture show up on this thing wasn't going to be as simple as I had hoped.</p><p>There are 16 pins wired up, each with two possible states: On or Off. This equates to 2<sup>16</sup> possible voltage states that the pins can be in. However, there are 64 LEDs wired up (disregarding the green LEDs), which equates to 2<sup>64</sup> possible LED states. This means that it's impossible to make any pattern of LEDs light up at a given time (it's a violation of the <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">Pigeonhole Principle</a>).</p><p>My plan instead, then, was to only ever display one pixel at a time. That might sound like a pretty silly way to make an image scroller, but this actually isn't too dissimilar to the way old-fashioned CRT monitors work.</p><p>By turning single LEDs on for fractions of a second and repeating, we can trick the human eye into perceiving a still image. By feeding multiple images into this process, we can make it look like an image is moving.</p><p>The other advantage of this approach is that current will only be drawn for 0 or 1 LED at any given instance. This means that standard resistors can be used. If we were lighting up multiple pixels in a given column at the same time, a more sophisticated method would have to be used (and with my current skillset, I don't know what that would be).</p><h2 id="step-4-the-code">Step 4: The Code</h2><p>I've included comments in the code below to act as an explanation:</p><!--kg-card-begin: code--><pre><code class="language-language-cpp">// The number of LEDs in the matrix in one dimension.
#define LED_MATRIX_SIZE 8

// The width of each letter when displayed on the matrix, including one column for
// spacing between letters.
#define LETTER_WIDTH 6
#define REPAINT_COUNT 50

// Red pins, in left-to-right order.
// Physical pin attachments to LED matrix: 11, 8, 5, 2, 14, 17, 20, 23.
const byte RED_PINS[LED_MATRIX_SIZE] = {2, 3, 4, 5, 6, 7, 8, 9};

// Ground pins, in top-to-bottom order (skip pin 13 to avoid using the integrated LED).
// Physical pin attachments to LED matrix: 22, 19, 16, 13, 3, 6, 9, 12.
const byte GROUND_PINS[LED_MATRIX_SIZE] = {A5, A4, A3, A2, A1, A0, 12, 11};

/* Binary representation of each letter, where 1 indicates an "On" pixel and 0 indicates
 * "Off", e.g. the letter "A" is defined as 0b0111010001111111000110001. Split into 5
 * rows and columns, that binary value looks like:
 * 0 1 1 1 0
 * 1 0 0 0 1
 * 1 1 1 1 1
 * 1 0 0 0 1
 * 1 0 0 0 1
 * 
 * Notice that the "1" pixels form a pixel representation of the letter "A". The same holds
 * true for the other letters defined below.
 */
const long LETTERS[] = {
  0b0111010001111111000110001, // 'A'
  0b1111010001111101000111110, // 'B'
  0b0111010001100001000101110, // 'C'
  0b1111010001100011000111110, // 'D'
  0b1111110000111101000011111, // 'E'
  0b1111110000111101000010000, // 'F'
  0b0111010000101111001001110, // 'G'
  0b1000110001111111000110001, // 'H'
  0b1111100100001000010011111, // 'I'
  0b0011100010000101001001100, // 'J'
  0b1000110010111001001010001, // 'K'
  0b1000010000100001000011111, // 'L'
  0b0101010101101011000110001, // 'M'
  0b1000111001101011001110001, // 'N'
  0b0111010001100011000101110, // 'O'
  0b1111010001111101000010000, // 'P'
  0b0110010010101101001001101, // 'Q'
  0b1111010001111101001010001, // 'R'
  0b0111110000011100000111110, // 'S'
  0b1111100100001000010000100, // 'T'
  0b1000110001100011000101110, // 'U'
  0b1000110001100010101000100, // 'V'
  0b1000110001101011101110001, // 'W'
  0b1000101010001000101010001, // 'X'
  0b1000101010001000010000100, // 'Y'
  0b1111100010001000100011111  // 'Z'
};

// Set all pins to output, so we can change the potential difference between
// positive and negative pins. We also default the cathode pins to HIGH, which creates
// a negative potential difference that results in no LEDs turning on.
void setup() {
  for (byte i = 0; i &lt; LED_MATRIX_SIZE; ++i) {
    byte anodePin = RED_PINS[i];
    pinMode(anodePin, OUTPUT);
    
    byte groundPin = GROUND_PINS[i];
    pinMode(groundPin, OUTPUT);

    digitalWrite(GROUND_PINS[i], HIGH);
  }
}

void loop() {
  renderMessage();
}

void renderMessage() {
  // The message to display on the screen, with some space for padding
  // when displaying the message.
  char message[] = " I AM ALIVE ";

  int messageIndex = 0;
  char messageChar = message[messageIndex];

  while (messageChar != '\0') {
    char nextChar = message[messageIndex + 1];
    if (nextChar == '\0') {
      nextChar = ' ';
    }

    renderFrame(messageChar, nextChar);

    ++messageIndex;
    messageChar = message[messageIndex]; 
  }
}

// 2 characters are always present on the screen. This function handles the drawing of those two
// characters in such a way that they scroll off the screen to the left. As soon as the first
// character is invisible, the function exits and is called again with a new secondChar,
// while the previous secondChar is passed in as the new firstChar.
void renderFrame(char firstChar, char secondChar) {
  for (byte i = 0; i &lt; LETTER_WIDTH; ++i) {
    for (byte j = 0; j &lt; REPAINT_COUNT; ++j) {
      boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE] = {};
      
      renderCharacter(frame, firstChar, -i);
      renderCharacter(frame, secondChar, 6 - i);

      renderFrame(frame);
      delay(1);
    }
  }
}

// Draws a pixel representation of a single letter to the frame buffer.
void renderCharacter(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE], char character, int offset) {
  for (int row = 0; row &lt; 5; ++row) {
    for (int col = 0; col &lt; 5; ++col) {
      int bitCount = (row * 5) + col;

      long displayCharacter;
      if (character == ' ') {
        displayCharacter = 0; // All spaces.
      } else {
        displayCharacter = LETTERS[character - 'A'];
      }

      // This is where the magic happens. The left shift and binary AND operations are used
      // together to effectively iterate over each bit of the character as defined in the
      // LETTERS array. This results in a 1 or 0, which is used to dictate whether a pixel
      // should be turned on or off for a given point.
      boolean isOn = displayCharacter &amp; (1L &lt;&lt; (24 - bitCount));

      // Only render the visible parts of the letter (part of the letter is likely to have
      // scrolled off the screen.
      int offsetCol = col + offset;
      if (offsetCol &gt;= 0 &amp;&amp; offsetCol &lt; LED_MATRIX_SIZE) {
        frame[row][offsetCol] = isOn;
      }
    }
  }
}

// Converts the in-memory frame buffer into an actual image. This is achieved by rapidly
// turning on single LEDs that correspond to "true" values in the frame buffer, then turning
// them off after a short delay.
// A single pixel is turned on by bringing the anode pin HIGH and the corresponding cathode pin
// LOW. Remember that all cathodes were brought HIGH earlier in the setup() function.
void renderFrame(boolean frame[LED_MATRIX_SIZE][LED_MATRIX_SIZE]) {
  for (byte row = 0; row &lt; LED_MATRIX_SIZE; ++row) {
    for (byte col = 0; col &lt; LED_MATRIX_SIZE; ++col) {
        // Turn pixel on or off as required.
        digitalWrite(RED_PINS[row], frame[row][col]);
        digitalWrite(GROUND_PINS[col], !frame[row][col]);

        // Turn pixel back off.
        digitalWrite(RED_PINS[row], LOW);
        digitalWrite(GROUND_PINS[col], HIGH);
    }
  }
}
</code></pre><!--kg-card-end: code--><h2 id="that-s-all-there-is-to-it">That's All There Is To It</h2><p>If you've made it to the end of this article, thanks for your patience. This is my first blog post of substance, and I'd love to hear any feedback or constructive criticism in the comments section below. Cheers!</p>]]></content:encoded></item><item><title><![CDATA[A Blog Is Born]]></title><description><![CDATA[Hi there, nice to meet you.

This is my first ever blog post. I've been meaning to do this for quite some
time, but I've struggled with motivation and ideas for content.

I'm a software engineer by trade, but recently I've been getting into
electronics. I picked up the Sparkfun Inventor's Kit
[https://www.sparkfun.com/products/12060] and now I'm hooked. I'm kind of
exploiting my newfound motivation for Making to kickstart my blog.

My plans for the blog aren't set in stone yet, but content will ]]></description><link>http://localhost:2368/a-blog-is-born/</link><guid isPermaLink="false">Ghost__Post__5d5ce55d5655c53c345c7e83</guid><category><![CDATA[electronics]]></category><category><![CDATA[software]]></category><dc:creator><![CDATA[Chris Parton]]></dc:creator><pubDate>Tue, 29 Sep 2015 02:29:00 GMT</pubDate><content:encoded><![CDATA[<p>Hi there, nice to meet you.</p><p>This is my first ever blog post. I've been meaning to do this for quite some time, but I've struggled with motivation and ideas for content.</p><p>I'm a software engineer by trade, but recently I've been getting into electronics. I picked up the <a href="https://www.sparkfun.com/products/12060">Sparkfun Inventor's Kit</a> and now I'm hooked. I'm kind of exploiting my newfound motivation for Making to kickstart my blog.</p><p>My plans for the blog aren't set in stone yet, but content will include:</p><ul><li>Electronics projects, which will hopefully increase in complexity and interestingness (that's a real word, I googled it) as I learn more.</li><li>Programming tidbits and grievances.</li><li>Reviews of software and tools that I use for the above.</li></ul><p>Anyway, this is it for now. I already have something to write about for my first electronics blog post, so exciting times ahead!</p><p>Cheers,<br>Chris</br></p>]]></content:encoded></item></channel></rss>